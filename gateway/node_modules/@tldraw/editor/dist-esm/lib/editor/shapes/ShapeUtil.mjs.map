{
  "version": 3,
  "sources": ["../../../../src/lib/editor/shapes/ShapeUtil.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Migrations } from '@tldraw/store'\nimport { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'\nimport { Box2d } from '../../primitives/Box2d'\nimport { Vec2d } from '../../primitives/Vec2d'\nimport { Geometry2d } from '../../primitives/geometry/Geometry2d'\nimport type { Editor } from '../Editor'\nimport { SvgExportContext } from '../types/SvgExportContext'\nimport { TLResizeHandle } from '../types/selection-types'\n\n/** @public */\nexport interface TLShapeUtilConstructor<\n\tT extends TLUnknownShape,\n\tU extends ShapeUtil<T> = ShapeUtil<T>\n> {\n\tnew (editor: Editor): U\n\ttype: T['type']\n\tprops?: ShapeProps<T>\n\tmigrations?: Migrations\n}\n\n/** @public */\nexport type TLShapeUtilFlag<T> = (shape: T) => boolean\n\n/** @public */\nexport interface TLShapeUtilCanvasSvgDef {\n\tkey: string\n\tcomponent: React.ComponentType\n}\n\n/** @public */\nexport abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {\n\tconstructor(public editor: Editor) {}\n\tstatic props?: ShapeProps<TLUnknownShape>\n\tstatic migrations?: Migrations\n\n\t/**\n\t * The type of the shape util, which should match the shape's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Get the default props for a shape.\n\t *\n\t * @public\n\t */\n\tabstract getDefaultProps(): Shape['props']\n\n\t/**\n\t * Get the shape's geometry.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract getGeometry(shape: Shape): Geometry2d\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract component(shape: Shape): any\n\n\t/**\n\t * Get JSX describing the shape's indicator (as an SVG element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract indicator(shape: Shape): any\n\n\t/**\n\t * Whether the shape can be snapped to by another shape.\n\t *\n\t * @public\n\t */\n\tcanSnap: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be scrolled while editing.\n\t *\n\t * @public\n\t */\n\tcanScroll: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.\n\t *\n\t * @public\n\t */\n\tcanUnmount: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be bound to by an arrow.\n\t *\n\t * @param _otherShape - The other shape attempting to bind to this shape.\n\t * @public\n\t */\n\tcanBind = <K>(_shape: Shape, _otherShape?: K) => true\n\n\t/**\n\t * Whether the shape can be double clicked to edit.\n\t *\n\t * @public\n\t */\n\tcanEdit: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape can be resized.\n\t *\n\t * @public\n\t */\n\tcanResize: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be edited in read-only mode.\n\t *\n\t * @public\n\t */\n\tcanEditInReadOnly: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape can be cropped.\n\t *\n\t * @public\n\t */\n\tcanCrop: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Does this shape provide a background for its children? If this is true,\n\t * then any children with a `renderBackground` method will have their\n\t * backgrounds rendered _above_ this shape. Otherwise, the children's\n\t * backgrounds will be rendered above either the next ancestor that provides\n\t * a background, or the canvas background.\n\t *\n\t * @internal\n\t */\n\tprovidesBackgroundForChildren(shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideResizeHandles: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideRotateHandle: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds background when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds foreground when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsFg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape's aspect ratio is locked.\n\t *\n\t * @public\n\t */\n\tisAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.\n\t *\n\t * @param shape - The shape.\n\t * @internal\n\t */\n\tbackgroundComponent?(shape: Shape): any\n\n\t/**\n\t * Get an array of handle models for the shape. This is an optional method.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getHandles?.(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tgetHandles?(shape: Shape): TLHandle[]\n\n\t/**\n\t * Get an array of outline segments for the shape. For most shapes,\n\t * this will be a single segment that includes the entire outline.\n\t * For shapes with handles, this might be segments of the outline\n\t * between each handle.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getOutlineSegments(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tgetOutlineSegments(shape: Shape): Vec2d[][] {\n\t\treturn [this.editor.getShapeGeometry(shape).vertices]\n\t}\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param type - The shape type.\n\t * @public\n\t */\n\tcanReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param shape - The shape type.\n\t * @param shapes - The shapes that are being dropped.\n\t * @public\n\t */\n\tcanDropShapes(shape: Shape, shapes: TLShape[]) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get the shape as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param ctx - The export context for the SVG - used for adding e.g. \\<def\\>s\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement>\n\n\t/**\n\t * Get the shape's background layer as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param ctx - ctx - The export context for the SVG - used for adding e.g. \\<def\\>s\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoBackgroundSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement> | null\n\n\t/** @internal */\n\texpandSelectionOutlinePx(shape: Shape): number {\n\t\treturn 0\n\t}\n\n\t/**\n\t * Return elements to be added to the \\<defs\\> section of the canvases SVG context. This can be\n\t * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg\n\t * elements returned by `component`.\n\t *\n\t * Each def should have a unique `key`. If multiple defs from different shapes all have the same\n\t * key, only one will be used.\n\t */\n\tgetCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn []\n\t}\n\n\t//  Events\n\n\t/**\n\t * A callback called just before a shape is created. This method provides a last chance to modify\n\t * the created shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeCreate = (next) => {\n\t * \treturn { ...next, x: next.x + 1 }\n\t * }\n\t * ```\n\t *\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeCreate?: TLOnBeforeCreateHandler<Shape>\n\n\t/**\n\t * A callback called just before a shape is updated. This method provides a last chance to modify\n\t * the updated shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeUpdate = (prev, next) => {\n\t * \tif (prev.x === next.x) {\n\t * \t\treturn { ...next, x: next.x + 1 }\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param prev - The previous shape.\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dragged over this one.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onDragShapesOver = (shape, shapes) => {\n\t * \treturn { shouldHint: true }\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged over this one.\n\t * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.\n\t * @public\n\t */\n\tonDragShapesOver?: TLOnDragHandler<Shape, { shouldHint: boolean }>\n\n\t/**\n\t * A callback called when some other shapes are dragged out of this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged out.\n\t * @public\n\t */\n\tonDragShapesOut?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dropped over this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dropped over this one.\n\t * @public\n\t */\n\tonDropShapesOver?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being resized.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeStart?: TLOnResizeStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a resize.\n\t *\n\t * @param shape - The shape at the start of the resize.\n\t * @param info - Info about the resize.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResize?: TLOnResizeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes resizing.\n\t *\n\t * @param initial - The shape at the start of the resize.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeEnd?: TLOnResizeEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being translated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateStart?: TLOnTranslateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a translation.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslate?: TLOnTranslateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes translating.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateEnd?: TLOnTranslateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being rotated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateStart?: TLOnRotateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a rotation.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotate?: TLOnRotateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes rotating.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateEnd?: TLOnRotateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle changes.\n\t *\n\t * @param shape - The current shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleChange?: TLOnHandleChangeHandler<Shape>\n\n\t/**\n\t * Not currently used.\n\t *\n\t * @internal\n\t */\n\tonBindingChange?: TLOnBindingChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's children change.\n\t *\n\t * @param shape - The shape.\n\t * @returns An array of shape updates, or void.\n\t * @public\n\t */\n\tonChildrenChange?: TLOnChildrenChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param handle - The handle that is double-clicked.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's edge is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickEdge?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClick?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonClick?: TLOnClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes being editing.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tonEditEnd?: TLOnEditEndHandler<Shape>\n}\n\n/** @public */\nexport type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void\n/** @public */\nexport type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void\n/** @public */\nexport type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/**\n * The type of resize.\n *\n * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.\n *\n * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize\n * handle. It is up to shape util implementers to decide how they want to handle the two\n * situations.\n *\n * @public\n */\nexport type TLResizeMode = 'scale_shape' | 'resize_bounds'\n\n/**\n * Info about a resize.\n * @param newPoint - The new local position of the shape.\n * @param handle - The handle being dragged.\n * @param mode - The type of resize.\n * @param scaleX - The scale in the x-axis.\n * @param scaleY - The scale in the y-axis.\n * @param initialBounds - The bounds of the shape at the start of the resize.\n * @param initialShape - The shape at the start of the resize.\n * @public\n */\nexport type TLResizeInfo<T extends TLShape> = {\n\tnewPoint: Vec2d\n\thandle: TLResizeHandle\n\tmode: TLResizeMode\n\tscaleX: number\n\tscaleY: number\n\tinitialBounds: Box2d\n\tinitialShape: T\n}\n\n/** @public */\nexport type TLOnResizeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: TLResizeInfo<T>\n) => Omit<TLShapePartial<T>, 'id' | 'type'> | undefined | void\n\n/** @public */\nexport type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>\n\n/** @public */\nexport type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/* -------------------- Dragging -------------------- */\n\n/** @public */\nexport type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R\n\n/** @internal */\nexport type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void\n\n/** @public */\nexport type TLOnHandleChangeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: {\n\t\thandle: TLHandle\n\t\tisPrecise: boolean\n\t\tinitial?: T | undefined\n\t}\n) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void\n/** @public */\nexport type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnDoubleClickHandleHandler<T extends TLShape> = (\n\tshape: T,\n\thandle: TLHandle\n) => TLShapePartial<T> | void\n\ntype TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\ntype TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void\n"],
  "mappings": "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",
  "names": []
}
