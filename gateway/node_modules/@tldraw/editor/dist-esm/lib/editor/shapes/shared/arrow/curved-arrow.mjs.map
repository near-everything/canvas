{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/shapes/shared/arrow/curved-arrow.ts"],
  "sourcesContent": ["import { TLArrowShape } from '@tldraw/tlschema'\nimport { Box2d } from '../../../../primitives/Box2d'\nimport { Matrix2d } from '../../../../primitives/Matrix2d'\nimport { Vec2d, VecLike } from '../../../../primitives/Vec2d'\nimport { intersectCirclePolygon, intersectCirclePolyline } from '../../../../primitives/intersect'\nimport {\n\tPI,\n\tPI2,\n\tclockwiseAngleDist,\n\tcounterClockwiseAngleDist,\n\tisSafeFloat,\n} from '../../../../primitives/utils'\nimport type { Editor } from '../../../Editor'\nimport { TLArcInfo, TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tWAY_TOO_BIG_ARROW_BEND_FACTOR,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n} from './shared'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nexport function getCurvedArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\textraBend = 0\n): TLArrowInfo {\n\tconst { arrowheadEnd, arrowheadStart } = shape.props\n\tconst bend = shape.props.bend + extraBend\n\n\tif (Math.abs(bend) > Math.abs(shape.props.bend * WAY_TOO_BIG_ARROW_BEND_FACTOR)) {\n\t\treturn getStraightArrowInfo(editor, shape)\n\t}\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape)\n\n\tconst med = Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end) // point between start and end\n\tconst u = Vec2d.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start).uni() // unit vector between start and end\n\tconst middle = Vec2d.Add(med, u.per().mul(-bend)) // middle handle\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.start)\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.end)\n\n\t// The positions of the body of the arrow, which may be different\n\t// than the arrow's start / end points if the arrow is bound to shapes\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = middle.clone()\n\n\tif (Vec2d.Equals(a, b)) {\n\t\treturn {\n\t\t\tisStraight: true,\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst isClockwise = shape.props.bend < 0\n\tconst distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist\n\n\tconst handleArc = getArcInfo(a, b, c)\n\tconst handle_aCA = Vec2d.Angle(handleArc.center, a)\n\tconst handle_aCB = Vec2d.Angle(handleArc.center, b)\n\tconst handle_dAB = distFn(handle_aCA, handle_aCB)\n\n\tif (\n\t\thandleArc.length === 0 ||\n\t\thandleArc.size === 0 ||\n\t\t!isSafeFloat(handleArc.length) ||\n\t\t!isSafeFloat(handleArc.size)\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape)\n\t}\n\n\tconst tempA = a.clone()\n\tconst tempB = b.clone()\n\tconst tempC = c.clone()\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\n\tif (startShapeInfo && !startShapeInfo.isExact) {\n\t\tconst startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, tempA)\n\t\tconst centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)\n\t\tconst endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, tempB)\n\n\t\tconst inverseTransform = Matrix2d.Inverse(startShapeInfo.transform)\n\n\t\tconst startInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst { isClosed } = startShapeInfo\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(centerInStartShapeLocalSpace, handleArc.radius, startShapeInfo.outline)\n\n\t\tif (intersections) {\n\t\t\tconst angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\n\t\t\t// Filter out any intersections that aren't in the arc\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tconst targetDist = dAB * 0.25\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0] ?? (isClosed ? undefined : startInStartShapeLocalSpace)\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : startInStartShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\ttempA.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(startShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tstartShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadStart !== 'none') {\n\t\t\t\toffsetA =\n\t\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t\t: 0)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endShapeInfo && !endShapeInfo.isExact) {\n\t\t// get points in shape's coordinates?\n\t\tconst startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, tempA)\n\t\tconst endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, tempB)\n\t\tconst centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\tconst inverseTransform = Matrix2d.Inverse(endShapeInfo.transform)\n\n\t\tconst startInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst isClosed = endShapeInfo.isClosed\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(centerInEndShapeLocalSpace, handleArc.radius, endShapeInfo.outline)\n\n\t\tif (intersections) {\n\t\t\tconst angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\t\t\tconst targetDist = dAB * 0.75\n\n\t\t\t// or simplified...\n\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tif (intersections[0]) {\n\t\t\t\tpoint = intersections[0]\n\t\t\t} else {\n\t\t\t\tpoint = isClosed ? undefined : endInEndShapeLocalSpace\n\t\t\t}\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : endInEndShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\t// Set b to target local point -> page point -> shape local point\n\t\t\ttempB.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(endShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tendShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadEnd !== 'none') {\n\t\t\t\toffsetB =\n\t\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply arrowhead offsets\n\n\tlet aCA = Vec2d.Angle(handleArc.center, tempA) // angle center -> a\n\tlet aCB = Vec2d.Angle(handleArc.center, tempB) // angle center -> b\n\tlet dAB = distFn(aCA, aCB) // angle distance between a and b\n\tlet lAB = dAB * handleArc.radius // length of arc between a and b\n\n\t// Try the offsets first, then check whether the distance between the points is too small;\n\t// if it is, flip the offsets and expand them. We need to do this using temporary points\n\t// so that we can apply them both in a balanced way.\n\tconst tA = tempA.clone()\n\tconst tB = tempB.clone()\n\n\tif (offsetA !== 0) {\n\t\tconst n = (offsetA / lAB) * (isClockwise ? 1 : -1)\n\t\tconst u = Vec2d.FromAngle(aCA + dAB * n)\n\t\ttA.setTo(handleArc.center).add(u.mul(handleArc.radius))\n\t}\n\n\tif (offsetB !== 0) {\n\t\tconst n = (offsetB / lAB) * (isClockwise ? -1 : 1)\n\t\tconst u = Vec2d.FromAngle(aCB + dAB * n)\n\t\ttB.setTo(handleArc.center).add(u.mul(handleArc.radius))\n\t}\n\n\tconst distAB = Vec2d.Dist(tA, tB)\n\tif (distAB < MIN_ARROW_LENGTH) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\toffsetA *= -2\n\t\t} else if (offsetB !== 0) {\n\t\t\toffsetB *= -2\n\t\t} else {\n\t\t\tif (distAB < 10) {\n\t\t\t\tif (startShapeInfo) offsetA = -(10 - distAB)\n\t\t\t\telse if (endShapeInfo) offsetB = -(10 - distAB)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (offsetA !== 0) {\n\t\tconst n = (offsetA / lAB) * (isClockwise ? 1 : -1)\n\t\tconst u = Vec2d.FromAngle(aCA + dAB * n)\n\t\ttempA.setTo(handleArc.center).add(u.mul(handleArc.radius))\n\t}\n\n\tif (offsetB !== 0) {\n\t\tconst n = (offsetB / lAB) * (isClockwise ? -1 : 1)\n\t\tconst u = Vec2d.FromAngle(aCB + dAB * n)\n\t\ttempB.setTo(handleArc.center).add(u.mul(handleArc.radius))\n\t}\n\n\t// Did we miss intersections? This happens when we have overlapping shapes.\n\tif (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n\t\taCA = Vec2d.Angle(handleArc.center, tempA) // angle center -> a\n\t\taCB = Vec2d.Angle(handleArc.center, tempB) // angle center -> b\n\t\tdAB = distFn(aCA, aCB) // angle distance between a and b\n\t\tlAB = dAB * handleArc.radius // length of arc between a and b\n\n\t\tif (startShapeInfo.shape === endShapeInfo.shape) {\n\t\t\tif (lAB < 100) {\n\t\t\t\ttempA.setTo(a)\n\t\t\t\ttempB.setTo(b)\n\t\t\t\ttempC.setTo(c)\n\t\t\t}\n\t\t} else {\n\t\t\tif (startShapeInfo && !startShapeInfo.didIntersect) {\n\t\t\t\ttempA.setTo(a)\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(endShapeInfo && !endShapeInfo.didIntersect) ||\n\t\t\t\tdistFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)\n\t\t\t) {\n\t\t\t\tconst n = Math.min(0.9, MIN_ARROW_LENGTH / lAB) * (isClockwise ? 1 : -1)\n\t\t\t\tconst u = Vec2d.FromAngle(aCA + dAB * n)\n\t\t\t\ttempB.setTo(handleArc.center).add(u.mul(handleArc.radius))\n\t\t\t}\n\t\t}\n\t}\n\n\tplaceCenterHandle(\n\t\thandleArc.center,\n\t\thandleArc.radius,\n\t\ttempA,\n\t\ttempB,\n\t\ttempC,\n\t\thandle_dAB,\n\t\tisClockwise\n\t)\n\n\tif (tempA.equals(tempB)) {\n\t\ttempA.setTo(tempC.clone().addXY(1, 1))\n\t\ttempB.setTo(tempC.clone().subXY(1, 1))\n\t}\n\n\ta.setTo(tempA)\n\tb.setTo(tempB)\n\tc.setTo(tempC)\n\tconst bodyArc = getArcInfo(a, b, c)\n\n\treturn {\n\t\tisStraight: false,\n\t\tstart: {\n\t\t\tpoint: a,\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\tpoint: b,\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\thandleArc,\n\t\tbodyArc,\n\t\tisValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),\n\t}\n}\n\n/**\n * Get a solid path for a curved arrow's handles.\n *\n * @param info - The arrow info.\n * @public\n */\nexport function getCurvedArrowHandlePath(info: TLArrowInfo & { isStraight: false }) {\n\tconst {\n\t\tstart,\n\t\tend,\n\t\thandleArc: { radius, largeArcFlag, sweepFlag },\n\t} = info\n\treturn `M${start.handle.x},${start.handle.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.handle.x},${end.handle.y}`\n}\n\n/**\n * Get a solid path for a curved arrow's body.\n *\n * @param info - The arrow info.\n * @public\n */\nexport function getSolidCurvedArrowPath(info: TLArrowInfo & { isStraight: false }) {\n\tconst {\n\t\tstart,\n\t\tend,\n\t\tbodyArc: { radius, largeArcFlag, sweepFlag },\n\t} = info\n\treturn `M${start.point.x},${start.point.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.point.x},${end.point.y}`\n}\n\n/**\n * Get a point along an arc.\n *\n * @param center - The arc's center.\n * @param radius - The arc's radius.\n * @param startAngle - The start point of the arc.\n * @param size - The size of the arc.\n * @param t - The point along the arc to get.\n */\nexport function getPointOnArc(\n\tcenter: VecLike,\n\tradius: number,\n\tstartAngle: number,\n\tsize: number,\n\tt: number\n) {\n\tconst angle = startAngle + size * t\n\treturn new Vec2d(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle))\n}\n\n/**\n * Get a bounding box for an arc.\n *\n * @param center - The arc's center.\n * @param radius - The arc's radius.\n * @param start - The start point of the arc.\n * @param size - The size of the arc.\n */\nexport function getArcBoundingBox(center: VecLike, radius: number, start: VecLike, size: number) {\n\tlet minX = Infinity\n\tlet minY = Infinity\n\tlet maxX = -Infinity\n\tlet maxY = -Infinity\n\n\tconst startAngle = Vec2d.Angle(center, start)\n\n\t// Test 20 points along the arc\n\tfor (let i = 0; i < 20; i++) {\n\t\tconst angle = startAngle + size * (i / 19)\n\t\tconst x = center.x + radius * Math.cos(angle)\n\t\tconst y = center.y + radius * Math.sin(angle)\n\n\t\tminX = Math.min(x, minX)\n\t\tminY = Math.min(y, minY)\n\t\tmaxX = Math.max(x, maxX)\n\t\tmaxY = Math.max(y, maxY)\n\t}\n\n\treturn new Box2d(minX, minY, maxX - minX, maxY - minY)\n}\n\n/**\n * Get info about an arc formed by three points.\n *\n * @param a - The start of the arc\n * @param b - The end of the arc\n * @param c - A point on the arc\n */\nexport function getArcInfo(a: VecLike, b: VecLike, c: VecLike): TLArcInfo {\n\t// find a circle from the three points\n\tconst u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y)\n\n\tconst center = {\n\t\tx:\n\t\t\t((a.x * a.x + a.y * a.y) * (c.y - b.y) +\n\t\t\t\t(b.x * b.x + b.y * b.y) * (a.y - c.y) +\n\t\t\t\t(c.x * c.x + c.y * c.y) * (b.y - a.y)) /\n\t\t\tu,\n\t\ty:\n\t\t\t((a.x * a.x + a.y * a.y) * (b.x - c.x) +\n\t\t\t\t(b.x * b.x + b.y * b.y) * (c.x - a.x) +\n\t\t\t\t(c.x * c.x + c.y * c.y) * (a.x - b.x)) /\n\t\t\tu,\n\t}\n\n\tconst radius = Vec2d.Dist(center, a)\n\n\t// Whether to draw the arc clockwise or counter-clockwise (are the points clockwise?)\n\tconst sweepFlag = +Vec2d.Clockwise(a, c, b)\n\n\t// The base angle of the arc in radians\n\tconst ab = Math.hypot(a.y - b.y, a.x - b.x)\n\tconst bc = Math.hypot(b.y - c.y, b.x - c.x)\n\tconst ca = Math.hypot(c.y - a.y, c.x - a.x)\n\n\tconst theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2\n\n\t// Whether to draw the long arc or short arc\n\tconst largeArcFlag = +(PI > theta)\n\n\t// The size of the arc to draw in radians\n\tconst size = (PI2 - theta) * (sweepFlag ? 1 : -1)\n\n\t// The length of the arc to draw in distance units\n\tconst length = size * radius\n\n\treturn {\n\t\tcenter,\n\t\tradius,\n\t\tsize,\n\t\tlength,\n\t\tlargeArcFlag,\n\t\tsweepFlag,\n\t}\n}\n\nfunction placeCenterHandle(\n\tcenter: VecLike,\n\tradius: number,\n\ttempA: Vec2d,\n\ttempB: Vec2d,\n\ttempC: Vec2d,\n\toriginalArcLength: number,\n\tisClockwise: boolean\n) {\n\tconst aCA = Vec2d.Angle(center, tempA) // angle center -> a\n\tconst aCB = Vec2d.Angle(center, tempB) // angle center -> b\n\tlet dAB = clockwiseAngleDist(aCA, aCB) // angle distance between a and b\n\tif (!isClockwise) dAB = PI2 - dAB\n\n\tconst n = 0.5 * (isClockwise ? 1 : -1)\n\tconst u = Vec2d.FromAngle(aCA + dAB * n)\n\ttempC.setTo(center).add(u.mul(radius))\n\n\tif (dAB > originalArcLength) {\n\t\ttempC.rotWith(center, PI)\n\t\tconst t = tempB.clone()\n\t\ttempB.setTo(tempA)\n\t\ttempA.setTo(t)\n\t}\n}\n"],
  "mappings": "AACA,SAAS,aAAa;AACtB,SAAS,gBAAgB;AACzB,SAAS,aAAsB;AAC/B,SAAS,wBAAwB,+BAA+B;AAChE;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AAGP;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACM;AACP,SAAS,4BAA4B;AAE9B,SAAS,mBACf,QACA,OACA,YAAY,GACE;AACd,QAAM,EAAE,cAAc,eAAe,IAAI,MAAM;AAC/C,QAAM,OAAO,MAAM,MAAM,OAAO;AAEhC,MAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,MAAM,MAAM,OAAO,6BAA6B,GAAG;AAChF,WAAO,qBAAqB,QAAQ,KAAK;AAAA,EAC1C;AAEA,QAAM,wBAAwB,8BAA8B,QAAQ,KAAK;AAEzE,QAAM,MAAM,MAAM,IAAI,sBAAsB,OAAO,sBAAsB,GAAG;AAC5E,QAAM,IAAI,MAAM,IAAI,sBAAsB,KAAK,sBAAsB,KAAK,EAAE,IAAI;AAChF,QAAM,SAAS,MAAM,IAAI,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;AAEhD,QAAM,iBAAiB,6BAA6B,QAAQ,MAAM,MAAM,KAAK;AAC7E,QAAM,eAAe,6BAA6B,QAAQ,MAAM,MAAM,GAAG;AAIzE,QAAM,IAAI,sBAAsB,MAAM,MAAM;AAC5C,QAAM,IAAI,sBAAsB,IAAI,MAAM;AAC1C,QAAM,IAAI,OAAO,MAAM;AAEvB,MAAI,MAAM,OAAO,GAAG,CAAC,GAAG;AACvB,WAAO;AAAA,MACN,YAAY;AAAA,MACZ,OAAO;AAAA,QACN,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,WAAW,MAAM,MAAM;AAAA,MACxB;AAAA,MACA,KAAK;AAAA,QACJ,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,WAAW,MAAM,MAAM;AAAA,MACxB;AAAA,MACA,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,QAAQ;AAAA,IACT;AAAA,EACD;AAEA,QAAM,cAAc,MAAM,MAAM,OAAO;AACvC,QAAM,SAAS,cAAc,qBAAqB;AAElD,QAAM,YAAY,WAAW,GAAG,GAAG,CAAC;AACpC,QAAM,aAAa,MAAM,MAAM,UAAU,QAAQ,CAAC;AAClD,QAAM,aAAa,MAAM,MAAM,UAAU,QAAQ,CAAC;AAClD,QAAM,aAAa,OAAO,YAAY,UAAU;AAEhD,MACC,UAAU,WAAW,KACrB,UAAU,SAAS,KACnB,CAAC,YAAY,UAAU,MAAM,KAC7B,CAAC,YAAY,UAAU,IAAI,GAC1B;AACD,WAAO,qBAAqB,QAAQ,KAAK;AAAA,EAC1C;AAEA,QAAM,QAAQ,EAAE,MAAM;AACtB,QAAM,QAAQ,EAAE,MAAM;AACtB,QAAM,QAAQ,EAAE,MAAM;AAEtB,QAAM,qBAAqB,OAAO,sBAAsB,KAAK;AAE7D,MAAI,UAAU;AACd,MAAI,UAAU;AAEd,MAAI,kBAAkB,CAAC,eAAe,SAAS;AAC9C,UAAM,mBAAmB,SAAS,aAAa,oBAAoB,KAAK;AACxE,UAAM,oBAAoB,SAAS,aAAa,oBAAoB,UAAU,MAAM;AACpF,UAAM,iBAAiB,SAAS,aAAa,oBAAoB,KAAK;AAEtE,UAAM,mBAAmB,SAAS,QAAQ,eAAe,SAAS;AAElE,UAAM,8BAA8B,SAAS,aAAa,kBAAkB,gBAAgB;AAC5F,UAAM,+BAA+B,SAAS,aAAa,kBAAkB,iBAAiB;AAC9F,UAAM,4BAA4B,SAAS,aAAa,kBAAkB,cAAc;AAExF,UAAM,EAAE,SAAS,IAAI;AACrB,UAAM,KAAK,WAAW,yBAAyB;AAE/C,QAAI;AAEJ,QAAI,gBAAgB,GAAG,8BAA8B,UAAU,QAAQ,eAAe,OAAO;AAE7F,QAAI,eAAe;AAClB,YAAM,eAAe,6BAA6B,MAAM,2BAA2B;AACnF,YAAM,aAAa,6BAA6B,MAAM,yBAAyB;AAC/E,YAAMA,OAAM,OAAO,cAAc,UAAU;AAG3C,sBAAgB,cAAc;AAAA,QAC7B,CAAC,OAAO,OAAO,cAAc,6BAA6B,MAAM,EAAE,CAAC,KAAKA;AAAA,MACzE;AAEA,YAAM,aAAaA,OAAM;AAEzB,oBAAc;AAAA,QACb,WACG,CAAC,IAAI,OACL,KAAK,IAAI,OAAO,cAAc,6BAA6B,MAAM,EAAE,CAAC,IAAI,UAAU,IAClF,KAAK,IAAI,OAAO,cAAc,6BAA6B,MAAM,EAAE,CAAC,IAAI,UAAU,IAC/E,KACA,IACH,CAAC,IAAI,OACL,OAAO,cAAc,6BAA6B,MAAM,EAAE,CAAC,IAC3D,OAAO,cAAc,6BAA6B,MAAM,EAAE,CAAC,IACxD,KACA;AAAA,MACP;AAEA,cAAQ,cAAc,CAAC,MAAM,WAAW,SAAY;AAAA,IACrD,OAAO;AACN,cAAQ,WAAW,SAAY;AAAA,IAChC;AAEA,QAAI,OAAO;AACV,YAAM;AAAA,QACL,OAAO,qBAAqB,OAAO,SAAS,aAAa,eAAe,WAAW,KAAK,CAAC;AAAA,MAC1F;AAEA,qBAAe,eAAe;AAE9B,UAAI,mBAAmB,QAAQ;AAC9B,kBACC,qBACA,aAAa,MAAM,MAAM,IAAI,IAAI,KAChC,UAAU,eAAe,MAAM,QAC7B,aAAa,eAAe,MAAM,MAAM,IAAI,IAAI,IAChD;AAAA,MACL;AAAA,IACD;AAAA,EACD;AAEA,MAAI,gBAAgB,CAAC,aAAa,SAAS;AAE1C,UAAM,mBAAmB,SAAS,aAAa,oBAAoB,KAAK;AACxE,UAAM,iBAAiB,SAAS,aAAa,oBAAoB,KAAK;AACtE,UAAM,oBAAoB,SAAS,aAAa,oBAAoB,UAAU,MAAM;AAEpF,UAAM,mBAAmB,SAAS,QAAQ,aAAa,SAAS;AAEhE,UAAM,4BAA4B,SAAS,aAAa,kBAAkB,gBAAgB;AAC1F,UAAM,6BAA6B,SAAS,aAAa,kBAAkB,iBAAiB;AAC5F,UAAM,0BAA0B,SAAS,aAAa,kBAAkB,cAAc;AAEtF,UAAM,WAAW,aAAa;AAC9B,UAAM,KAAK,WAAW,yBAAyB;AAE/C,QAAI;AAEJ,QAAI,gBAAgB,GAAG,4BAA4B,UAAU,QAAQ,aAAa,OAAO;AAEzF,QAAI,eAAe;AAClB,YAAM,eAAe,2BAA2B,MAAM,yBAAyB;AAC/E,YAAM,aAAa,2BAA2B,MAAM,uBAAuB;AAC3E,YAAMA,OAAM,OAAO,cAAc,UAAU;AAC3C,YAAM,aAAaA,OAAM;AAIzB,sBAAgB,cAAc;AAAA,QAC7B,CAAC,OAAO,OAAO,cAAc,2BAA2B,MAAM,EAAE,CAAC,KAAKA;AAAA,MACvE;AAEA,oBAAc;AAAA,QACb,WACG,CAAC,IAAI,OACL,KAAK,IAAI,OAAO,cAAc,2BAA2B,MAAM,EAAE,CAAC,IAAI,UAAU,IAChF,KAAK,IAAI,OAAO,cAAc,2BAA2B,MAAM,EAAE,CAAC,IAAI,UAAU,IAC7E,KACA,IACH,CAAC,IAAI,OACL,OAAO,cAAc,2BAA2B,MAAM,EAAE,CAAC,IACzD,OAAO,cAAc,2BAA2B,MAAM,EAAE,CAAC,IACtD,KACA;AAAA,MACP;AAEA,UAAI,cAAc,CAAC,GAAG;AACrB,gBAAQ,cAAc,CAAC;AAAA,MACxB,OAAO;AACN,gBAAQ,WAAW,SAAY;AAAA,MAChC;AAAA,IACD,OAAO;AACN,cAAQ,WAAW,SAAY;AAAA,IAChC;AAEA,QAAI,OAAO;AAEV,YAAM;AAAA,QACL,OAAO,qBAAqB,OAAO,SAAS,aAAa,aAAa,WAAW,KAAK,CAAC;AAAA,MACxF;AAEA,mBAAa,eAAe;AAE5B,UAAI,iBAAiB,QAAQ;AAC5B,kBACC,qBACA,aAAa,MAAM,MAAM,IAAI,IAAI,KAChC,UAAU,aAAa,MAAM,QAAQ,aAAa,aAAa,MAAM,MAAM,IAAI,IAAI,IAAI;AAAA,MAC1F;AAAA,IACD;AAAA,EACD;AAIA,MAAI,MAAM,MAAM,MAAM,UAAU,QAAQ,KAAK;AAC7C,MAAI,MAAM,MAAM,MAAM,UAAU,QAAQ,KAAK;AAC7C,MAAI,MAAM,OAAO,KAAK,GAAG;AACzB,MAAI,MAAM,MAAM,UAAU;AAK1B,QAAM,KAAK,MAAM,MAAM;AACvB,QAAM,KAAK,MAAM,MAAM;AAEvB,MAAI,YAAY,GAAG;AAClB,UAAM,IAAK,UAAU,OAAQ,cAAc,IAAI;AAC/C,UAAMC,KAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,OAAG,MAAM,UAAU,MAAM,EAAE,IAAIA,GAAE,IAAI,UAAU,MAAM,CAAC;AAAA,EACvD;AAEA,MAAI,YAAY,GAAG;AAClB,UAAM,IAAK,UAAU,OAAQ,cAAc,KAAK;AAChD,UAAMA,KAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,OAAG,MAAM,UAAU,MAAM,EAAE,IAAIA,GAAE,IAAI,UAAU,MAAM,CAAC;AAAA,EACvD;AAEA,QAAM,SAAS,MAAM,KAAK,IAAI,EAAE;AAChC,MAAI,SAAS,kBAAkB;AAC9B,QAAI,YAAY,KAAK,YAAY,GAAG;AACnC,iBAAW;AACX,iBAAW;AAAA,IACZ,WAAW,YAAY,GAAG;AACzB,iBAAW;AAAA,IACZ,WAAW,YAAY,GAAG;AACzB,iBAAW;AAAA,IACZ,OAAO;AACN,UAAI,SAAS,IAAI;AAChB,YAAI;AAAgB,oBAAU,EAAE,KAAK;AAAA,iBAC5B;AAAc,oBAAU,EAAE,KAAK;AAAA,MACzC;AAAA,IACD;AAAA,EACD;AAEA,MAAI,YAAY,GAAG;AAClB,UAAM,IAAK,UAAU,OAAQ,cAAc,IAAI;AAC/C,UAAMA,KAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,UAAM,MAAM,UAAU,MAAM,EAAE,IAAIA,GAAE,IAAI,UAAU,MAAM,CAAC;AAAA,EAC1D;AAEA,MAAI,YAAY,GAAG;AAClB,UAAM,IAAK,UAAU,OAAQ,cAAc,KAAK;AAChD,UAAMA,KAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,UAAM,MAAM,UAAU,MAAM,EAAE,IAAIA,GAAE,IAAI,UAAU,MAAM,CAAC;AAAA,EAC1D;AAGA,MAAI,kBAAkB,gBAAgB,CAAC,eAAe,WAAW,CAAC,aAAa,SAAS;AACvF,UAAM,MAAM,MAAM,UAAU,QAAQ,KAAK;AACzC,UAAM,MAAM,MAAM,UAAU,QAAQ,KAAK;AACzC,UAAM,OAAO,KAAK,GAAG;AACrB,UAAM,MAAM,UAAU;AAEtB,QAAI,eAAe,UAAU,aAAa,OAAO;AAChD,UAAI,MAAM,KAAK;AACd,cAAM,MAAM,CAAC;AACb,cAAM,MAAM,CAAC;AACb,cAAM,MAAM,CAAC;AAAA,MACd;AAAA,IACD,OAAO;AACN,UAAI,kBAAkB,CAAC,eAAe,cAAc;AACnD,cAAM,MAAM,CAAC;AAAA,MACd;AAEA,UACE,gBAAgB,CAAC,aAAa,gBAC/B,OAAO,YAAY,GAAG,IAAI,OAAO,YAAY,GAAG,GAC/C;AACD,cAAM,IAAI,KAAK,IAAI,KAAK,mBAAmB,GAAG,KAAK,cAAc,IAAI;AACrE,cAAMA,KAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,cAAM,MAAM,UAAU,MAAM,EAAE,IAAIA,GAAE,IAAI,UAAU,MAAM,CAAC;AAAA,MAC1D;AAAA,IACD;AAAA,EACD;AAEA;AAAA,IACC,UAAU;AAAA,IACV,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI,MAAM,OAAO,KAAK,GAAG;AACxB,UAAM,MAAM,MAAM,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC;AACrC,UAAM,MAAM,MAAM,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC;AAAA,EACtC;AAEA,IAAE,MAAM,KAAK;AACb,IAAE,MAAM,KAAK;AACb,IAAE,MAAM,KAAK;AACb,QAAM,UAAU,WAAW,GAAG,GAAG,CAAC;AAElC,SAAO;AAAA,IACN,YAAY;AAAA,IACZ,OAAO;AAAA,MACN,OAAO;AAAA,MACP,QAAQ,sBAAsB;AAAA,MAC9B,WAAW,MAAM,MAAM;AAAA,IACxB;AAAA,IACA,KAAK;AAAA,MACJ,OAAO;AAAA,MACP,QAAQ,sBAAsB;AAAA,MAC9B,WAAW,MAAM,MAAM;AAAA,IACxB;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA,SAAS,QAAQ,WAAW,KAAK,SAAS,QAAQ,OAAO,CAAC,KAAK,SAAS,QAAQ,OAAO,CAAC;AAAA,EACzF;AACD;AAQO,SAAS,yBAAyB,MAA2C;AACnF,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA,WAAW,EAAE,QAAQ,cAAc,UAAU;AAAA,EAC9C,IAAI;AACJ,SAAO,IAAI,MAAM,OAAO,CAAC,IAAI,MAAM,OAAO,CAAC,KAAK,MAAM,IAAI,MAAM,MAAM,YAAY,IAAI,SAAS,IAAI,IAAI,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC;AAChI;AAQO,SAAS,wBAAwB,MAA2C;AAClF,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA,SAAS,EAAE,QAAQ,cAAc,UAAU;AAAA,EAC5C,IAAI;AACJ,SAAO,IAAI,MAAM,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC,KAAK,MAAM,IAAI,MAAM,MAAM,YAAY,IAAI,SAAS,IAAI,IAAI,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC;AAC5H;AAWO,SAAS,cACf,QACA,QACA,YACA,MACA,GACC;AACD,QAAM,QAAQ,aAAa,OAAO;AAClC,SAAO,IAAI,MAAM,OAAO,IAAI,SAAS,KAAK,IAAI,KAAK,GAAG,OAAO,IAAI,SAAS,KAAK,IAAI,KAAK,CAAC;AAC1F;AAUO,SAAS,kBAAkB,QAAiB,QAAgB,OAAgB,MAAc;AAChG,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AAEX,QAAM,aAAa,MAAM,MAAM,QAAQ,KAAK;AAG5C,WAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC5B,UAAM,QAAQ,aAAa,QAAQ,IAAI;AACvC,UAAM,IAAI,OAAO,IAAI,SAAS,KAAK,IAAI,KAAK;AAC5C,UAAM,IAAI,OAAO,IAAI,SAAS,KAAK,IAAI,KAAK;AAE5C,WAAO,KAAK,IAAI,GAAG,IAAI;AACvB,WAAO,KAAK,IAAI,GAAG,IAAI;AACvB,WAAO,KAAK,IAAI,GAAG,IAAI;AACvB,WAAO,KAAK,IAAI,GAAG,IAAI;AAAA,EACxB;AAEA,SAAO,IAAI,MAAM,MAAM,MAAM,OAAO,MAAM,OAAO,IAAI;AACtD;AASO,SAAS,WAAW,GAAY,GAAY,GAAuB;AAEzE,QAAM,IAAI,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAE5E,QAAM,SAAS;AAAA,IACd,KACG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MACpC;AAAA,IACD,KACG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAClC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MACpC;AAAA,EACF;AAEA,QAAM,SAAS,MAAM,KAAK,QAAQ,CAAC;AAGnC,QAAM,YAAY,CAAC,MAAM,UAAU,GAAG,GAAG,CAAC;AAG1C,QAAM,KAAK,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAC1C,QAAM,KAAK,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAC1C,QAAM,KAAK,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAE1C,QAAM,QAAQ,KAAK,MAAM,KAAK,KAAK,KAAK,KAAK,KAAK,OAAO,IAAI,KAAK,GAAG,IAAI;AAGzE,QAAM,eAAe,EAAE,KAAK;AAG5B,QAAM,QAAQ,MAAM,UAAU,YAAY,IAAI;AAG9C,QAAM,SAAS,OAAO;AAEtB,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;AAEA,SAAS,kBACR,QACA,QACA,OACA,OACA,OACA,mBACA,aACC;AACD,QAAM,MAAM,MAAM,MAAM,QAAQ,KAAK;AACrC,QAAM,MAAM,MAAM,MAAM,QAAQ,KAAK;AACrC,MAAI,MAAM,mBAAmB,KAAK,GAAG;AACrC,MAAI,CAAC;AAAa,UAAM,MAAM;AAE9B,QAAM,IAAI,OAAO,cAAc,IAAI;AACnC,QAAM,IAAI,MAAM,UAAU,MAAM,MAAM,CAAC;AACvC,QAAM,MAAM,MAAM,EAAE,IAAI,EAAE,IAAI,MAAM,CAAC;AAErC,MAAI,MAAM,mBAAmB;AAC5B,UAAM,QAAQ,QAAQ,EAAE;AACxB,UAAM,IAAI,MAAM,MAAM;AACtB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,CAAC;AAAA,EACd;AACD;",
  "names": ["dAB", "u"]
}
