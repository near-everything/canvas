{
  "version": 3,
  "sources": ["../../../../src/lib/editor/tools/StateNode.ts"],
  "sourcesContent": ["import { Atom, Computed, atom, computed } from '@tldraw/state'\nimport type { Editor } from '../Editor'\nimport {\n\tEVENT_NAME_MAP,\n\tTLEnterEventHandler,\n\tTLEventHandlers,\n\tTLEventInfo,\n\tTLExitEventHandler,\n\tTLPinchEventInfo,\n} from '../types/event-types'\n\ntype TLStateNodeType = 'branch' | 'leaf' | 'root'\n\n/** @public */\nexport interface TLStateNodeConstructor {\n\tnew (editor: Editor, parent?: StateNode): StateNode\n\tid: string\n\tinitial?: string\n\tchildren?: () => TLStateNodeConstructor[]\n}\n\n/** @public */\nexport abstract class StateNode implements Partial<TLEventHandlers> {\n\tconstructor(public editor: Editor, parent?: StateNode) {\n\t\tconst { id, children, initial } = this.constructor as TLStateNodeConstructor\n\n\t\tthis.id = id\n\t\tthis._isActive = atom<boolean>('toolIsActive' + this.id, false)\n\t\tthis._current = atom<StateNode | undefined>('toolState' + this.id, undefined)\n\n\t\tthis._path = computed('toolPath' + this.id, () => {\n\t\t\tconst current = this.getCurrent()\n\t\t\treturn this.id + (current ? `.${current.getPath()}` : '')\n\t\t})\n\n\t\tthis.parent = parent ?? ({} as any)\n\n\t\tif (this.parent) {\n\t\t\tif (children && initial) {\n\t\t\t\tthis.type = 'branch'\n\t\t\t\tthis.initial = initial\n\t\t\t\tthis.children = Object.fromEntries(\n\t\t\t\t\tchildren().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])\n\t\t\t\t)\n\t\t\t\tthis._current.set(this.children[this.initial])\n\t\t\t} else {\n\t\t\t\tthis.type = 'leaf'\n\t\t\t}\n\t\t} else {\n\t\t\tthis.type = 'root'\n\n\t\t\tif (children && initial) {\n\t\t\t\tthis.initial = initial\n\t\t\t\tthis.children = Object.fromEntries(\n\t\t\t\t\tchildren().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])\n\t\t\t\t)\n\t\t\t\tthis._current.set(this.children[this.initial])\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic id: string\n\tstatic initial?: string\n\tstatic children?: () => TLStateNodeConstructor[]\n\n\tid: string\n\ttype: TLStateNodeType\n\tshapeType?: string\n\tinitial?: string\n\tchildren?: Record<string, StateNode>\n\tparent: StateNode\n\n\t/**\n\t * This node's path of active state nodes\n\t *\n\t * @public\n\t */\n\t@computed getPath() {\n\t\treturn this._path.get()\n\t}\n\t_path: Computed<string>\n\n\t/**\n\t * This node's current active child node, if any.\n\t *\n\t * @public\n\t */\n\t@computed getCurrent() {\n\t\treturn this._current.get()\n\t}\n\tprivate _current: Atom<StateNode | undefined>\n\n\t/**\n\t * Whether this node is active.\n\t *\n\t * @public\n\t */\n\t@computed getIsActive() {\n\t\treturn this._isActive.get()\n\t}\n\tprivate _isActive: Atom<boolean>\n\n\t/**\n\t * Transition to a new active child state node.\n\t *\n\t * @example\n\t * ```ts\n\t * parentState.transition('childStateA')\n\t * parentState.transition('childStateB', { myData: 4 })\n\t *```\n\t *\n\t * @param id - The id of the child state node to transition to.\n\t * @param info - Any data to pass to the `onEnter` and `onExit` handlers.\n\t *\n\t * @public\n\t */\n\ttransition = (id: string, info: any = {}) => {\n\t\tconst path = id.split('.')\n\n\t\tlet currState = this as StateNode\n\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tconst id = path[i]\n\t\t\tconst prevChildState = currState.getCurrent()\n\t\t\tconst nextChildState = currState.children?.[id]\n\n\t\t\tif (!nextChildState) {\n\t\t\t\tthrow Error(`${currState.id} - no child state exists with the id ${id}.`)\n\t\t\t}\n\n\t\t\tif (prevChildState?.id !== nextChildState.id) {\n\t\t\t\tprevChildState?.exit(info, id)\n\t\t\t\tcurrState._current.set(nextChildState)\n\t\t\t\tnextChildState.enter(info, prevChildState?.id || 'initial')\n\t\t\t\tif (!nextChildState.getIsActive()) break\n\t\t\t}\n\n\t\t\tcurrState = nextChildState\n\t\t}\n\n\t\treturn this\n\t}\n\n\thandleEvent = (info: Exclude<TLEventInfo, TLPinchEventInfo>) => {\n\t\tconst cbName = EVENT_NAME_MAP[info.name]\n\t\tconst x = this.getCurrent()\n\t\tthis[cbName]?.(info as any)\n\t\tif (this.getCurrent() === x && this.getIsActive()) {\n\t\t\tx?.handleEvent(info)\n\t\t}\n\t}\n\n\t// todo: move this logic into transition\n\tenter = (info: any, from: string) => {\n\t\tthis._isActive.set(true)\n\t\tthis.onEnter?.(info, from)\n\t\tif (this.children && this.initial && this.getIsActive()) {\n\t\t\tconst initial = this.children[this.initial]\n\t\t\tthis._current.set(initial)\n\t\t\tinitial.enter(info, from)\n\t\t}\n\t}\n\n\t// todo: move this logic into transition\n\texit = (info: any, from: string) => {\n\t\tthis._isActive.set(false)\n\t\tthis.onExit?.(info, from)\n\t\tif (!this.getIsActive()) {\n\t\t\tthis.getCurrent()?.exit(info, from)\n\t\t}\n\t}\n\n\t/**\n\t * This is a hack / escape hatch that will tell the editor to\n\t * report a different state as active (in `getCurrentToolId()`) when\n\t * this state is active. This is usually used when a tool transitions\n\t * to a child of a different state for a certain interaction and then\n\t * returns to the original tool when that interaction completes; and\n\t * where we would want to show the original tool as active in the UI.\n\t *\n\t * @public\n\t */\n\t_currentToolIdMask = atom('curent tool id mask', undefined as string | undefined)\n\n\t@computed get currentToolIdMask() {\n\t\treturn this._currentToolIdMask.get()\n\t}\n\n\tset currentToolIdMask(id: string | undefined) {\n\t\tthis._currentToolIdMask.set(id)\n\t}\n\n\tonWheel?: TLEventHandlers['onWheel']\n\tonPointerDown?: TLEventHandlers['onPointerDown']\n\tonPointerMove?: TLEventHandlers['onPointerMove']\n\tonPointerUp?: TLEventHandlers['onPointerUp']\n\tonDoubleClick?: TLEventHandlers['onDoubleClick']\n\tonTripleClick?: TLEventHandlers['onTripleClick']\n\tonQuadrupleClick?: TLEventHandlers['onQuadrupleClick']\n\tonRightClick?: TLEventHandlers['onRightClick']\n\tonMiddleClick?: TLEventHandlers['onMiddleClick']\n\tonKeyDown?: TLEventHandlers['onKeyDown']\n\tonKeyUp?: TLEventHandlers['onKeyUp']\n\tonKeyRepeat?: TLEventHandlers['onKeyRepeat']\n\tonCancel?: TLEventHandlers['onCancel']\n\tonComplete?: TLEventHandlers['onComplete']\n\tonInterrupt?: TLEventHandlers['onInterrupt']\n\n\tonEnter?: TLEnterEventHandler\n\tonExit?: TLExitEventHandler\n}\n"],
  "mappings": "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",
  "names": ["id"]
}
