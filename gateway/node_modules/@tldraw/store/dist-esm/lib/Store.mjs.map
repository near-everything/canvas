{
  "version": 3,
  "sources": ["../../src/lib/Store.ts"],
  "sourcesContent": ["import { Atom, Computed, Reactor, atom, computed, reactor, transact } from '@tldraw/state'\nimport {\n\tfilterEntries,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n\tthrottledRaf,\n} from '@tldraw/utils'\nimport { nanoid } from 'nanoid'\nimport { IdOf, RecordId, UnknownRecord } from './BaseRecord'\nimport { Cache } from './Cache'\nimport { RecordScope } from './RecordType'\nimport { StoreQueries } from './StoreQueries'\nimport { SerializedSchema, StoreSchema } from './StoreSchema'\nimport { devFreeze } from './devFreeze'\n\ntype RecFromId<K extends RecordId<UnknownRecord>> = K extends RecordId<infer R> ? R : never\n\n/**\n * A diff describing the changes to a record.\n *\n * @public\n */\nexport type RecordsDiff<R extends UnknownRecord> = {\n\tadded: Record<IdOf<R>, R>\n\tupdated: Record<IdOf<R>, [from: R, to: R]>\n\tremoved: Record<IdOf<R>, R>\n}\n\n/**\n * A diff describing the changes to a collection.\n *\n * @public\n */\nexport type CollectionDiff<T> = { added?: Set<T>; removed?: Set<T> }\n\nexport type ChangeSource = 'user' | 'remote'\n\nexport type StoreListenerFilters = {\n\tsource: ChangeSource | 'all'\n\tscope: RecordScope | 'all'\n}\n\n/**\n * An entry containing changes that originated either by user actions or remote changes.\n *\n * @public\n */\nexport type HistoryEntry<R extends UnknownRecord = UnknownRecord> = {\n\tchanges: RecordsDiff<R>\n\tsource: ChangeSource\n}\n\n/**\n * A function that will be called when the history changes.\n *\n * @public\n */\nexport type StoreListener<R extends UnknownRecord> = (entry: HistoryEntry<R>) => void\n\n/**\n * A record store is a collection of records of different types.\n *\n * @public\n */\nexport type ComputedCache<Data, R extends UnknownRecord> = {\n\tget(id: IdOf<R>): Data | undefined\n}\n\n/**\n * A serialized snapshot of the record store's values.\n *\n * @public\n */\nexport type SerializedStore<R extends UnknownRecord> = Record<IdOf<R>, R>\n\n/** @public */\nexport type StoreSnapshot<R extends UnknownRecord> = {\n\tstore: SerializedStore<R>\n\tschema: SerializedSchema\n}\n\n/** @public */\nexport type StoreValidator<R extends UnknownRecord> = {\n\tvalidate: (record: unknown) => R\n}\n\n/** @public */\nexport type StoreValidators<R extends UnknownRecord> = {\n\t[K in R['typeName']]: StoreValidator<Extract<R, { typeName: K }>>\n}\n\n/** @public */\nexport type StoreError = {\n\terror: Error\n\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\trecordBefore?: unknown\n\trecordAfter: unknown\n\tisExistingValidationIssue: boolean\n}\n\n/** @internal */\nexport type StoreRecord<S extends Store<any>> = S extends Store<infer R> ? R : never\n\n/**\n * A store of records.\n *\n * @public\n */\nexport class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {\n\t/**\n\t * The random id of the store.\n\t */\n\tpublic readonly id = nanoid()\n\t/**\n\t * An atom containing the store's atoms.\n\t *\n\t * @internal\n\t * @readonly\n\t */\n\tprivate readonly atoms = atom('store_atoms', {} as Record<IdOf<R>, Atom<R>>)\n\n\t/**\n\t * An atom containing the store's history.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly history: Atom<number, RecordsDiff<R>> = atom('history', 0, {\n\t\thistoryLength: 1000,\n\t})\n\n\t/**\n\t * A StoreQueries instance for this store.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly query = new StoreQueries<R>(this.atoms, this.history)\n\n\t/**\n\t * A set containing listeners that have been added to this store.\n\t *\n\t * @internal\n\t */\n\tprivate listeners = new Set<{ onHistory: StoreListener<R>; filters: StoreListenerFilters }>()\n\n\t/**\n\t * An array of history entries that have not yet been flushed.\n\t *\n\t * @internal\n\t */\n\tprivate historyAccumulator = new HistoryAccumulator<R>()\n\n\t/**\n\t * A reactor that responds to changes to the history by squashing the accumulated history and\n\t * notifying listeners of the changes.\n\t *\n\t * @internal\n\t */\n\tprivate historyReactor: Reactor\n\n\treadonly schema: StoreSchema<R, Props>\n\n\treadonly props: Props\n\n\tpublic readonly scopedTypes: { readonly [K in RecordScope]: ReadonlySet<R['typeName']> }\n\n\tconstructor(config: {\n\t\t/** The store's initial data. */\n\t\tinitialData?: SerializedStore<R>\n\t\t/**\n\t\t * A map of validators for each record type. A record's validator will be called when the record\n\t\t * is created or updated. It should throw an error if the record is invalid.\n\t\t */\n\t\tschema: StoreSchema<R, Props>\n\t\tprops: Props\n\t}) {\n\t\tconst { initialData, schema } = config\n\n\t\tthis.schema = schema\n\t\tthis.props = config.props\n\n\t\tif (initialData) {\n\t\t\tthis.atoms.set(\n\t\t\t\tobjectMapFromEntries(\n\t\t\t\t\tobjectMapEntries(initialData).map(([id, record]) => [\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tatom('atom:' + id, this.schema.validateRecord(this, record, 'initialize', null)),\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tthis.historyReactor = reactor(\n\t\t\t'Store.historyReactor',\n\t\t\t() => {\n\t\t\t\t// deref to make sure we're subscribed regardless of whether we need to propagate\n\t\t\t\tthis.history.get()\n\t\t\t\t// If we have accumulated history, flush it and update listeners\n\t\t\t\tthis._flushHistory()\n\t\t\t},\n\t\t\t{ scheduleEffect: (cb) => throttledRaf(cb) }\n\t\t)\n\t\tthis.scopedTypes = {\n\t\t\tdocument: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tsession: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'session')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tpresence: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'presence')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t}\n\t}\n\n\tpublic _flushHistory() {\n\t\t// If we have accumulated history, flush it and update listeners\n\t\tif (this.historyAccumulator.hasChanges()) {\n\t\t\tconst entries = this.historyAccumulator.flush()\n\t\t\tfor (const { changes, source } of entries) {\n\t\t\t\tlet instanceChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet documentChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet presenceChanges = null as null | RecordsDiff<R>\n\t\t\t\tfor (const { onHistory, filters } of this.listeners) {\n\t\t\t\t\tif (filters.source !== 'all' && filters.source !== source) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif (filters.scope !== 'all') {\n\t\t\t\t\t\tif (filters.scope === 'document') {\n\t\t\t\t\t\t\tdocumentChanges ??= this.filterChangesByScope(changes, 'document')\n\t\t\t\t\t\t\tif (!documentChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: documentChanges, source })\n\t\t\t\t\t\t} else if (filters.scope === 'session') {\n\t\t\t\t\t\t\tinstanceChanges ??= this.filterChangesByScope(changes, 'session')\n\t\t\t\t\t\t\tif (!instanceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: instanceChanges, source })\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpresenceChanges ??= this.filterChangesByScope(changes, 'presence')\n\t\t\t\t\t\t\tif (!presenceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: presenceChanges, source })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonHistory({ changes, source })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters out non-document changes from a diff. Returns null if there are no changes left.\n\t * @param change - the records diff\n\t * @returns\n\t */\n\tfilterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {\n\t\tconst result = {\n\t\t\tadded: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t\tupdated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),\n\t\t\tremoved: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t}\n\t\tif (\n\t\t\tObject.keys(result.added).length === 0 &&\n\t\t\tObject.keys(result.updated).length === 0 &&\n\t\t\tObject.keys(result.removed).length === 0\n\t\t) {\n\t\t\treturn null\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Update the history with a diff of changes.\n\t *\n\t * @param changes - The changes to add to the history.\n\t */\n\tprivate updateHistory(changes: RecordsDiff<R>): void {\n\t\tthis.historyAccumulator.add({\n\t\t\tchanges,\n\t\t\tsource: this.isMergingRemoteChanges ? 'remote' : 'user',\n\t\t})\n\t\tif (this.listeners.size === 0) {\n\t\t\tthis.historyAccumulator.clear()\n\t\t}\n\t\tthis.history.set(this.history.get() + 1, changes)\n\t}\n\n\tvalidate(phase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests') {\n\t\tthis.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))\n\t}\n\n\t/**\n\t * A callback fired after each record's change.\n\t *\n\t * @param prev - The previous value, if any.\n\t * @param next - The next value.\n\t */\n\tonBeforeCreate?: (next: R, source: 'remote' | 'user') => R\n\n\t/**\n\t * A callback fired after a record is created. Use this to perform related updates to other\n\t * records in the store.\n\t *\n\t * @param record - The record to be created\n\t */\n\tonAfterCreate?: (record: R, source: 'remote' | 'user') => void\n\n\t/**\n\t * A callback before after each record's change.\n\t *\n\t * @param prev - The previous value, if any.\n\t * @param next - The next value.\n\t */\n\tonBeforeChange?: (prev: R, next: R, source: 'remote' | 'user') => R\n\n\t/**\n\t * A callback fired after each record's change.\n\t *\n\t * @param prev - The previous value, if any.\n\t * @param next - The next value.\n\t */\n\tonAfterChange?: (prev: R, next: R, source: 'remote' | 'user') => void\n\n\t/**\n\t * A callback fired before a record is deleted.\n\t *\n\t * @param prev - The record that will be deleted.\n\t */\n\tonBeforeDelete?: (prev: R, source: 'remote' | 'user') => false | void\n\n\t/**\n\t * A callback fired after a record is deleted.\n\t *\n\t * @param prev - The record that will be deleted.\n\t */\n\tonAfterDelete?: (prev: R, source: 'remote' | 'user') => void\n\n\t// used to avoid running callbacks when rolling back changes in sync client\n\tprivate _runCallbacks = true\n\n\t/**\n\t * Add some records to the store. It's an error if they already exist.\n\t *\n\t * @param records - The records to add.\n\t * @public\n\t */\n\tput = (records: R[], phaseOverride?: 'initialize'): void => {\n\t\ttransact(() => {\n\t\t\tconst updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}\n\t\t\tconst additions: Record<IdOf<UnknownRecord>, R> = {}\n\n\t\t\tconst currentMap = this.atoms.__unsafe__getWithoutCapture()\n\t\t\tlet map = null as null | Record<IdOf<UnknownRecord>, Atom<R>>\n\n\t\t\t// Iterate through all records, creating, updating or removing as needed\n\t\t\tlet record: R\n\n\t\t\t// There's a chance that, despite having records, all of the values are\n\t\t\t// identical to what they were before; and so we'd end up with an \"empty\"\n\t\t\t// history entry. Let's keep track of whether we've actually made any\n\t\t\t// changes (e.g. additions, deletions, or updates that produce a new value).\n\t\t\tlet didChange = false\n\n\t\t\tconst beforeCreate = this.onBeforeCreate && this._runCallbacks ? this.onBeforeCreate : null\n\t\t\tconst beforeUpdate = this.onBeforeChange && this._runCallbacks ? this.onBeforeChange : null\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tfor (let i = 0, n = records.length; i < n; i++) {\n\t\t\t\trecord = records[i]\n\n\t\t\t\tconst recordAtom = (map ?? currentMap)[record.id as IdOf<R>]\n\n\t\t\t\tif (recordAtom) {\n\t\t\t\t\tif (beforeUpdate) record = beforeUpdate(recordAtom.get(), record, source)\n\n\t\t\t\t\t// If we already have an atom for this record, update its value.\n\n\t\t\t\t\tconst initialValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tphaseOverride ?? 'updateRecord',\n\t\t\t\t\t\tinitialValue\n\t\t\t\t\t)\n\n\t\t\t\t\trecordAtom.set(devFreeze(record))\n\n\t\t\t\t\t// need to deref atom in case nextValue is not identical but is .equals?\n\t\t\t\t\tconst finalValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// If the value has changed, assign it to updates.\n\t\t\t\t\tif (initialValue !== finalValue) {\n\t\t\t\t\t\tdidChange = true\n\t\t\t\t\t\tupdates[record.id] = [initialValue, finalValue]\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (beforeCreate) record = beforeCreate(record, source)\n\n\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t// If we don't have an atom, create one.\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord as R,\n\t\t\t\t\t\tphaseOverride ?? 'createRecord',\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\n\t\t\t\t\t// Mark the change as a new addition.\n\t\t\t\t\tadditions[record.id] = record\n\n\t\t\t\t\t// Assign the atom to the map under the record's id.\n\t\t\t\t\tif (!map) {\n\t\t\t\t\t\tmap = { ...currentMap }\n\t\t\t\t\t}\n\t\t\t\t\tmap[record.id] = atom('atom:' + record.id, record)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the map of atoms to the store.\n\t\t\tif (map) {\n\t\t\t\tthis.atoms.set(map)\n\t\t\t}\n\n\t\t\t// If we did change, update the history\n\t\t\tif (!didChange) return\n\t\t\tthis.updateHistory({\n\t\t\t\tadded: additions,\n\t\t\t\tupdated: updates,\n\t\t\t\tremoved: {} as Record<IdOf<R>, R>,\n\t\t\t})\n\n\t\t\tif (this._runCallbacks) {\n\t\t\t\tconst { onAfterCreate, onAfterChange } = this\n\n\t\t\t\tif (onAfterCreate) {\n\t\t\t\t\t// Run the onAfterChange callback for addition.\n\t\t\t\t\tObject.values(additions).forEach((record) => {\n\t\t\t\t\t\tonAfterCreate(record, source)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (onAfterChange) {\n\t\t\t\t\t// Run the onAfterChange callback for update.\n\t\t\t\t\tObject.values(updates).forEach(([from, to]) => {\n\t\t\t\t\t\tonAfterChange(from, to, source)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Remove some records from the store via their ids.\n\t *\n\t * @param ids - The ids of the records to remove.\n\t * @public\n\t */\n\tremove = (ids: IdOf<R>[]): void => {\n\t\ttransact(() => {\n\t\t\tconst cancelled = [] as IdOf<R>[]\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tif (this.onBeforeDelete && this._runCallbacks) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tconst atom = this.atoms.__unsafe__getWithoutCapture()[id]\n\t\t\t\t\tif (!atom) continue\n\n\t\t\t\t\tif (this.onBeforeDelete(atom.get(), source) === false) {\n\t\t\t\t\t\tcancelled.push(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet removed = undefined as undefined | RecordsDiff<R>['removed']\n\n\t\t\t// For each map in our atoms, remove the ids that we are removing.\n\t\t\tthis.atoms.update((atoms) => {\n\t\t\t\tlet result: typeof atoms | undefined = undefined\n\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tif (cancelled.includes(id)) continue\n\t\t\t\t\tif (!(id in atoms)) continue\n\t\t\t\t\tif (!result) result = { ...atoms }\n\t\t\t\t\tif (!removed) removed = {} as Record<IdOf<R>, R>\n\t\t\t\t\tdelete result[id]\n\t\t\t\t\tremoved[id] = atoms[id].get()\n\t\t\t\t}\n\n\t\t\t\treturn result ?? atoms\n\t\t\t})\n\n\t\t\tif (!removed) return\n\t\t\t// Update the history with the removed records.\n\t\t\tthis.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)\n\n\t\t\t// If we have an onAfterChange, run it for each removed record.\n\t\t\tif (this.onAfterDelete && this._runCallbacks) {\n\t\t\t\tlet record: R\n\t\t\t\tfor (let i = 0, n = ids.length; i < n; i++) {\n\t\t\t\t\trecord = removed[ids[i]]\n\t\t\t\t\tif (record) {\n\t\t\t\t\t\tthis.onAfterDelete(record, source)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Get the value of a store record by its id.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tget = <K extends IdOf<R>>(id: K): RecFromId<K> | undefined => {\n\t\treturn this.atoms.get()[id]?.get() as any\n\t}\n\n\t/**\n\t * Get the value of a store record by its id without updating its epoch.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tunsafeGetWithoutCapture = <K extends IdOf<R>>(id: K): RecFromId<K> | undefined => {\n\t\treturn this.atoms.get()[id]?.__unsafe__getWithoutCapture() as any\n\t}\n\n\t/**\n\t * Creates a JSON payload from the record store.\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t * @returns The record store snapshot as a JSON payload.\n\t */\n\tserialize = (scope: RecordScope | 'all' = 'document'): SerializedStore<R> => {\n\t\tconst result = {} as SerializedStore<R>\n\t\tfor (const [id, atom] of objectMapEntries(this.atoms.get())) {\n\t\t\tconst record = atom.get()\n\t\t\tif (scope === 'all' || this.scopedTypes[scope].has(record.typeName)) {\n\t\t\t\tresult[id as IdOf<R>] = record\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.loadSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t *\n\t * @public\n\t */\n\tgetSnapshot(scope: RecordScope | 'all' = 'document'): StoreSnapshot<R> {\n\t\treturn {\n\t\t\tstore: this.serialize(scope),\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * Migrate a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.migrateSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tmigrateSnapshot(snapshot: StoreSnapshot<R>): StoreSnapshot<R> {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\treturn {\n\t\t\tstore: migrationResult.value,\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * Load a serialized snapshot.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.loadSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tloadSnapshot(snapshot: StoreSnapshot<R>): void {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tthis.clear()\n\t\t\tthis.put(Object.values(migrationResult.value))\n\t\t\tthis.ensureStoreIsUsable()\n\t\t})\n\t}\n\n\t/**\n\t * Get an array of all values in the store.\n\t *\n\t * @returns An array of all values in the store.\n\t * @public\n\t */\n\tallRecords = (): R[] => {\n\t\treturn objectMapValues(this.atoms.get()).map((atom) => atom.get())\n\t}\n\n\t/**\n\t * Removes all records from the store.\n\t *\n\t * @public\n\t */\n\tclear = (): void => {\n\t\tthis.remove(objectMapKeys(this.atoms.get()))\n\t}\n\n\t/**\n\t * Update a record. To update multiple records at once, use the `update` method of the\n\t * `TypedStore` class.\n\t *\n\t * @param id - The id of the record to update.\n\t * @param updater - A function that updates the record.\n\t */\n\tupdate = <K extends IdOf<R>>(id: K, updater: (record: RecFromId<K>) => RecFromId<K>) => {\n\t\tconst atom = this.atoms.get()[id]\n\t\tif (!atom) {\n\t\t\tconsole.error(`Record ${id} not found. This is probably an error`)\n\t\t\treturn\n\t\t}\n\n\t\tthis.put([updater(atom.__unsafe__getWithoutCapture() as any as RecFromId<K>) as any])\n\t}\n\n\t/**\n\t * Get whether the record store has a id.\n\t *\n\t * @param id - The id of the record to check.\n\t * @public\n\t */\n\thas = <K extends IdOf<R>>(id: K): boolean => {\n\t\treturn !!this.atoms.get()[id]\n\t}\n\n\t/**\n\t * Add a new listener to the store.\n\t *\n\t * @param onHistory - The listener to call when the store updates.\n\t * @param filters - Filters to apply to the listener.\n\t * @returns A function to remove the listener.\n\t */\n\tlisten = (onHistory: StoreListener<R>, filters?: Partial<StoreListenerFilters>) => {\n\t\t// flush history so that this listener's history starts from exactly now\n\t\tthis._flushHistory()\n\n\t\tconst listener = {\n\t\t\tonHistory,\n\t\t\tfilters: {\n\t\t\t\tsource: filters?.source ?? 'all',\n\t\t\t\tscope: filters?.scope ?? 'all',\n\t\t\t},\n\t\t}\n\n\t\tthis.listeners.add(listener)\n\n\t\tif (!this.historyReactor.scheduler.isActivelyListening) {\n\t\t\tthis.historyReactor.start()\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener)\n\n\t\t\tif (this.listeners.size === 0) {\n\t\t\t\tthis.historyReactor.stop()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isMergingRemoteChanges = false\n\n\t/**\n\t * Merge changes from a remote source without triggering listeners.\n\t *\n\t * @param fn - A function that merges the external changes.\n\t * @public\n\t */\n\tmergeRemoteChanges = (fn: () => void) => {\n\t\tif (this.isMergingRemoteChanges) {\n\t\t\treturn fn()\n\t\t}\n\n\t\ttry {\n\t\t\tthis.isMergingRemoteChanges = true\n\t\t\ttransact(fn)\n\t\t} finally {\n\t\t\tthis.isMergingRemoteChanges = false\n\t\t}\n\t}\n\n\textractingChanges(fn: () => void): RecordsDiff<R> {\n\t\tconst changes: Array<RecordsDiff<R>> = []\n\t\tconst dispose = this.historyAccumulator.intercepting((entry) => changes.push(entry.changes))\n\t\ttry {\n\t\t\ttransact(fn)\n\t\t\treturn squashRecordDiffs(changes)\n\t\t} finally {\n\t\t\tdispose()\n\t\t}\n\t}\n\n\tapplyDiff(diff: RecordsDiff<R>, runCallbacks = true) {\n\t\tconst prevRunCallbacks = this._runCallbacks\n\t\ttry {\n\t\t\tthis._runCallbacks = runCallbacks\n\t\t\ttransact(() => {\n\t\t\t\tconst toPut = objectMapValues(diff.added).concat(\n\t\t\t\t\tobjectMapValues(diff.updated).map(([_from, to]) => to)\n\t\t\t\t)\n\t\t\t\tconst toRemove = objectMapKeys(diff.removed)\n\t\t\t\tif (toPut.length) {\n\t\t\t\t\tthis.put(toPut)\n\t\t\t\t}\n\t\t\t\tif (toRemove.length) {\n\t\t\t\t\tthis.remove(toRemove)\n\t\t\t\t}\n\t\t\t})\n\t\t} finally {\n\t\t\tthis._runCallbacks = prevRunCallbacks\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache.\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateComputedCache = <T, V extends R = R>(\n\t\tname: string,\n\t\tderive: (record: V) => T | undefined,\n\t\tisEqual?: (a: V, b: V) => boolean\n\t): ComputedCache<T, V> => {\n\t\tconst cache = new Cache<Atom<any>, Computed<T | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<V>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => {\n\t\t\t\t\t\tconst recordSignal = isEqual\n\t\t\t\t\t\t\t? computed(atom.name + ':equals', () => atom.get(), { isEqual })\n\t\t\t\t\t\t\t: atom\n\t\t\t\t\t\treturn computed<T | undefined>(name + ':' + id, () => {\n\t\t\t\t\t\t\treturn derive(recordSignal.get() as V)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache from a selector\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param selector - A function that returns a subset of the original shape\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateSelectedComputedCache = <T, J, V extends R = R>(\n\t\tname: string,\n\t\tselector: (record: V) => T | undefined,\n\t\tderive: (input: T) => J | undefined\n\t): ComputedCache<J, V> => {\n\t\tconst cache = new Cache<Atom<any>, Computed<J | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<V>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\n\t\t\t\tconst d = computed<T | undefined>(name + ':' + id + ':selector', () =>\n\t\t\t\t\tselector(atom.get() as V)\n\t\t\t\t)\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => computed<J | undefined>(name + ':' + id, () => derive(d.get() as T)))\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\tgetRecordType = <T extends R>(record: R): T => {\n\t\tconst type = this.schema.types[record.typeName as R['typeName']]\n\t\tif (!type) {\n\t\t\tthrow new Error(`Record type ${record.typeName} not found`)\n\t\t}\n\t\treturn type as unknown as T\n\t}\n\n\tprivate _integrityChecker?: () => void | undefined\n\n\t/** @internal */\n\tensureStoreIsUsable() {\n\t\tthis._integrityChecker ??= this.schema.createIntegrityChecker(this)\n\t\tthis._integrityChecker?.()\n\t}\n\n\tprivate _isPossiblyCorrupted = false\n\t/** @internal */\n\tmarkAsPossiblyCorrupted() {\n\t\tthis._isPossiblyCorrupted = true\n\t}\n\t/** @internal */\n\tisPossiblyCorrupted() {\n\t\treturn this._isPossiblyCorrupted\n\t}\n}\n\n/**\n * Squash a collection of diffs into a single diff.\n *\n * @param diffs - An array of diffs to squash.\n * @returns A single diff that represents the squashed diffs.\n * @public\n */\nexport function squashRecordDiffs<T extends UnknownRecord>(\n\tdiffs: RecordsDiff<T>[]\n): RecordsDiff<T> {\n\tconst result = { added: {}, removed: {}, updated: {} } as RecordsDiff<T>\n\n\tfor (const diff of diffs) {\n\t\tfor (const [id, value] of objectMapEntries(diff.added)) {\n\t\t\tif (result.removed[id]) {\n\t\t\t\tconst original = result.removed[id]\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tif (original !== value) {\n\t\t\t\t\tresult.updated[id] = [original, value]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.added[id] = value\n\t\t\t}\n\t\t}\n\n\t\tfor (const [id, [_from, to]] of objectMapEntries(diff.updated)) {\n\t\t\tif (result.added[id]) {\n\t\t\t\tresult.added[id] = to\n\t\t\t\tdelete result.updated[id]\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (result.updated[id]) {\n\t\t\t\tresult.updated[id][1] = to\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresult.updated[id] = diff.updated[id]\n\t\t\tdelete result.removed[id]\n\t\t}\n\n\t\tfor (const [id, value] of objectMapEntries(diff.removed)) {\n\t\t\t// the same record was added in this diff sequence, just drop it\n\t\t\tif (result.added[id]) {\n\t\t\t\tdelete result.added[id]\n\t\t\t} else if (result.updated[id]) {\n\t\t\t\tresult.removed[id] = result.updated[id][0]\n\t\t\t\tdelete result.updated[id]\n\t\t\t} else {\n\t\t\t\tresult.removed[id] = value\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * Collect all history entries by their sources.\n *\n * @param entries - The array of history entries.\n * @returns A map of history entries by their sources.\n * @public\n */\nfunction squashHistoryEntries<T extends UnknownRecord>(\n\tentries: HistoryEntry<T>[]\n): HistoryEntry<T>[] {\n\tconst result: HistoryEntry<T>[] = []\n\n\tlet current = entries[0]\n\tlet entry: HistoryEntry<T>\n\n\tfor (let i = 1, n = entries.length; i < n; i++) {\n\t\tentry = entries[i]\n\n\t\tif (current.source !== entry.source) {\n\t\t\tresult.push(current)\n\t\t\tcurrent = entry\n\t\t} else {\n\t\t\tcurrent = {\n\t\t\t\tsource: current.source,\n\t\t\t\tchanges: squashRecordDiffs([current.changes, entry.changes]),\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.push(current)\n\n\treturn result\n}\n\n/** @public */\nexport function reverseRecordsDiff(diff: RecordsDiff<any>) {\n\tconst result: RecordsDiff<any> = { added: diff.removed, removed: diff.added, updated: {} }\n\tfor (const [from, to] of Object.values(diff.updated)) {\n\t\tresult.updated[from.id] = [to, from]\n\t}\n\treturn result\n}\n\nclass HistoryAccumulator<T extends UnknownRecord> {\n\tprivate _history: HistoryEntry<T>[] = []\n\n\tprivate _interceptors: Set<(entry: HistoryEntry<T>) => void> = new Set()\n\n\tintercepting(fn: (entry: HistoryEntry<T>) => void) {\n\t\tthis._interceptors.add(fn)\n\t\treturn () => {\n\t\t\tthis._interceptors.delete(fn)\n\t\t}\n\t}\n\n\tadd(entry: HistoryEntry<T>) {\n\t\tthis._history.push(entry)\n\t\tfor (const interceptor of this._interceptors) {\n\t\t\tinterceptor(entry)\n\t\t}\n\t}\n\n\tflush() {\n\t\tconst history = squashHistoryEntries(this._history)\n\t\tthis._history = []\n\t\treturn history\n\t}\n\n\tclear() {\n\t\tthis._history = []\n\t}\n\n\thasChanges() {\n\t\treturn this._history.length > 0\n\t}\n}\n"],
  "mappings": "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",
  "names": ["record", "atom"]
}
