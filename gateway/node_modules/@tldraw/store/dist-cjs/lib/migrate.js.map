{
  "version": 3,
  "sources": ["../../src/lib/migrate.ts"],
  "sourcesContent": ["import { UnknownRecord, isRecord } from './BaseRecord'\nimport { SerializedSchema } from './StoreSchema'\n\ntype EMPTY_SYMBOL = symbol\n\n/** @public */\nexport function defineMigrations<\n\tFirstVersion extends number | EMPTY_SYMBOL = EMPTY_SYMBOL,\n\tCurrentVersion extends Exclude<number, 0> | EMPTY_SYMBOL = EMPTY_SYMBOL\n>(opts: {\n\tfirstVersion?: CurrentVersion extends number ? FirstVersion : never\n\tcurrentVersion?: CurrentVersion\n\tmigrators?: CurrentVersion extends number\n\t\t? FirstVersion extends number\n\t\t\t? CurrentVersion extends FirstVersion\n\t\t\t\t? { [version in Exclude<Range<1, CurrentVersion>, 0>]: Migration }\n\t\t\t\t: { [version in Exclude<Range<FirstVersion, CurrentVersion>, FirstVersion>]: Migration }\n\t\t\t: { [version in Exclude<Range<1, CurrentVersion>, 0>]: Migration }\n\t\t: never\n\tsubTypeKey?: string\n\tsubTypeMigrations?: Record<string, BaseMigrationsInfo>\n}): Migrations {\n\tconst { currentVersion, firstVersion, migrators = {}, subTypeKey, subTypeMigrations } = opts\n\n\t// Some basic guards against impossible version combinations, some of which will be caught by TypeScript\n\tif (typeof currentVersion === 'number' && typeof firstVersion === 'number') {\n\t\tif ((currentVersion as number) === (firstVersion as number)) {\n\t\t\tthrow Error(`Current version is equal to initial version.`)\n\t\t} else if (currentVersion < firstVersion) {\n\t\t\tthrow Error(`Current version is lower than initial version.`)\n\t\t}\n\t}\n\n\treturn {\n\t\tfirstVersion: (firstVersion as number) ?? 0, // defaults\n\t\tcurrentVersion: (currentVersion as number) ?? 0, // defaults\n\t\tmigrators,\n\t\tsubTypeKey,\n\t\tsubTypeMigrations,\n\t}\n}\n\n/** @public */\nexport type Migration<Before = any, After = any> = {\n\tup: (oldState: Before) => After\n\tdown: (newState: After) => Before\n}\n\ninterface BaseMigrationsInfo {\n\tfirstVersion: number\n\tcurrentVersion: number\n\tmigrators: { [version: number]: Migration }\n}\n\n/** @public */\nexport interface Migrations extends BaseMigrationsInfo {\n\tsubTypeKey?: string\n\tsubTypeMigrations?: Record<string, BaseMigrationsInfo>\n}\n\n/** @public */\nexport type MigrationResult<T> =\n\t| { type: 'success'; value: T }\n\t| { type: 'error'; reason: MigrationFailureReason }\n\n/** @public */\nexport enum MigrationFailureReason {\n\tIncompatibleSubtype = 'incompatible-subtype',\n\tUnknownType = 'unknown-type',\n\tTargetVersionTooNew = 'target-version-too-new',\n\tTargetVersionTooOld = 'target-version-too-old',\n\tMigrationError = 'migration-error',\n\tUnrecognizedSubtype = 'unrecognized-subtype',\n}\n\n/** @public */\nexport type RecordVersion = { rootVersion: number; subTypeVersion?: number }\n/** @public */\nexport function getRecordVersion(\n\trecord: UnknownRecord,\n\tserializedSchema: SerializedSchema\n): RecordVersion {\n\tconst persistedType = serializedSchema.recordVersions[record.typeName]\n\tif (!persistedType) {\n\t\treturn { rootVersion: 0 }\n\t}\n\tif ('subTypeKey' in persistedType) {\n\t\tconst subType = record[persistedType.subTypeKey as keyof typeof record]\n\t\tconst subTypeVersion = persistedType.subTypeVersions[subType]\n\t\treturn { rootVersion: persistedType.version, subTypeVersion }\n\t}\n\treturn { rootVersion: persistedType.version }\n}\n\n/** @public */\nexport function compareRecordVersions(a: RecordVersion, b: RecordVersion) {\n\tif (a.rootVersion > b.rootVersion) {\n\t\treturn 1\n\t}\n\tif (a.rootVersion < b.rootVersion) {\n\t\treturn -1\n\t}\n\tif (a.subTypeVersion != null && b.subTypeVersion != null) {\n\t\tif (a.subTypeVersion > b.subTypeVersion) {\n\t\t\treturn 1\n\t\t}\n\t\tif (a.subTypeVersion < b.subTypeVersion) {\n\t\t\treturn -1\n\t\t}\n\t}\n\treturn 0\n}\n\n/** @public */\nexport function migrateRecord<R extends UnknownRecord>({\n\trecord,\n\tmigrations,\n\tfromVersion,\n\ttoVersion,\n}: {\n\trecord: unknown\n\tmigrations: Migrations\n\tfromVersion: number\n\ttoVersion: number\n}): MigrationResult<R> {\n\tlet currentVersion = fromVersion\n\tif (!isRecord(record)) throw new Error('[migrateRecord] object is not a record')\n\tconst { typeName, id, ...others } = record\n\tlet recordWithoutMeta = others\n\n\twhile (currentVersion < toVersion) {\n\t\tconst nextVersion = currentVersion + 1\n\t\tconst migrator = migrations.migrators[nextVersion]\n\t\tif (!migrator) {\n\t\t\treturn {\n\t\t\t\ttype: 'error',\n\t\t\t\treason: MigrationFailureReason.TargetVersionTooNew,\n\t\t\t}\n\t\t}\n\t\trecordWithoutMeta = migrator.up(recordWithoutMeta) as any\n\t\tcurrentVersion = nextVersion\n\t}\n\n\twhile (currentVersion > toVersion) {\n\t\tconst nextVersion = currentVersion - 1\n\t\tconst migrator = migrations.migrators[currentVersion]\n\t\tif (!migrator) {\n\t\t\treturn {\n\t\t\t\ttype: 'error',\n\t\t\t\treason: MigrationFailureReason.TargetVersionTooOld,\n\t\t\t}\n\t\t}\n\t\trecordWithoutMeta = migrator.down(recordWithoutMeta) as any\n\t\tcurrentVersion = nextVersion\n\t}\n\n\treturn {\n\t\ttype: 'success',\n\t\tvalue: { ...recordWithoutMeta, id, typeName } as any,\n\t}\n}\n\n/** @public */\nexport function migrate<T>({\n\tvalue,\n\tmigrations,\n\tfromVersion,\n\ttoVersion,\n}: {\n\tvalue: unknown\n\tmigrations: Migrations\n\tfromVersion: number\n\ttoVersion: number\n}): MigrationResult<T> {\n\tlet currentVersion = fromVersion\n\n\twhile (currentVersion < toVersion) {\n\t\tconst nextVersion = currentVersion + 1\n\t\tconst migrator = migrations.migrators[nextVersion]\n\t\tif (!migrator) {\n\t\t\treturn {\n\t\t\t\ttype: 'error',\n\t\t\t\treason: MigrationFailureReason.TargetVersionTooNew,\n\t\t\t}\n\t\t}\n\t\tvalue = migrator.up(value)\n\t\tcurrentVersion = nextVersion\n\t}\n\n\twhile (currentVersion > toVersion) {\n\t\tconst nextVersion = currentVersion - 1\n\t\tconst migrator = migrations.migrators[currentVersion]\n\t\tif (!migrator) {\n\t\t\treturn {\n\t\t\t\ttype: 'error',\n\t\t\t\treason: MigrationFailureReason.TargetVersionTooOld,\n\t\t\t}\n\t\t}\n\t\tvalue = migrator.down(value)\n\t\tcurrentVersion = nextVersion\n\t}\n\n\treturn {\n\t\ttype: 'success',\n\t\tvalue: value as T,\n\t}\n}\n\ntype Range<From extends number, To extends number> = To extends From\n\t? From\n\t: To | Range<From, Decrement<To>>\n\ntype Decrement<n extends number> = n extends 0\n\t? never\n\t: n extends 1\n\t? 0\n\t: n extends 2\n\t? 1\n\t: n extends 3\n\t? 2\n\t: n extends 4\n\t? 3\n\t: n extends 5\n\t? 4\n\t: n extends 6\n\t? 5\n\t: n extends 7\n\t? 6\n\t: n extends 8\n\t? 7\n\t: n extends 9\n\t? 8\n\t: n extends 10\n\t? 9\n\t: n extends 11\n\t? 10\n\t: n extends 12\n\t? 11\n\t: n extends 13\n\t? 12\n\t: n extends 14\n\t? 13\n\t: n extends 15\n\t? 14\n\t: n extends 16\n\t? 15\n\t: n extends 17\n\t? 16\n\t: n extends 18\n\t? 17\n\t: n extends 19\n\t? 18\n\t: n extends 20\n\t? 19\n\t: n extends 21\n\t? 20\n\t: n extends 22\n\t? 21\n\t: n extends 23\n\t? 22\n\t: n extends 24\n\t? 23\n\t: n extends 25\n\t? 24\n\t: n extends 26\n\t? 25\n\t: n extends 27\n\t? 26\n\t: n extends 28\n\t? 27\n\t: n extends 29\n\t? 28\n\t: n extends 30\n\t? 29\n\t: n extends 31\n\t? 30\n\t: n extends 32\n\t? 31\n\t: n extends 33\n\t? 32\n\t: n extends 34\n\t? 33\n\t: n extends 35\n\t? 34\n\t: n extends 36\n\t? 35\n\t: n extends 37\n\t? 36\n\t: n extends 38\n\t? 37\n\t: n extends 39\n\t? 38\n\t: n extends 40\n\t? 39\n\t: n extends 41\n\t? 40\n\t: n extends 42\n\t? 41\n\t: n extends 43\n\t? 42\n\t: n extends 44\n\t? 43\n\t: n extends 45\n\t? 44\n\t: n extends 46\n\t? 45\n\t: n extends 47\n\t? 46\n\t: n extends 48\n\t? 47\n\t: n extends 49\n\t? 48\n\t: n extends 50\n\t? 49\n\t: n extends 51\n\t? 50\n\t: never\n"],
  "mappings": "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",
  "names": ["MigrationFailureReason"]
}
