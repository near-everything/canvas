{
  "version": 3,
  "sources": ["../../../../../src/lib/shapes/draw/toolStates/Drawing.ts"],
  "sourcesContent": ["import {\n\tDRAG_DISTANCE,\n\tMatrix2d,\n\tStateNode,\n\tTLDefaultSizeStyle,\n\tTLDrawShape,\n\tTLDrawShapeSegment,\n\tTLEventHandlers,\n\tTLHighlightShape,\n\tTLPointerEventInfo,\n\tTLShapePartial,\n\tVec2d,\n\tVec2dModel,\n\tcreateShapeId,\n\tlast,\n\tsnapAngle,\n\ttoFixed,\n\tuniqueId,\n} from '@tldraw/editor'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\n\ntype DrawableShape = TLDrawShape | TLHighlightShape\n\nexport class Drawing extends StateNode {\n\tstatic override id = 'drawing'\n\n\tinfo = {} as TLPointerEventInfo\n\n\tinitialShape?: DrawableShape\n\n\toverride shapeType = this.parent.id === 'highlight' ? ('highlight' as const) : ('draw' as const)\n\n\tutil = this.editor.getShapeUtil(this.shapeType)\n\n\tisPen = false\n\n\tsegmentMode = 'free' as 'free' | 'straight' | 'starting_straight' | 'starting_free'\n\n\tdidJustShiftClickToExtendPreviousShapeLine = false\n\n\tpagePointWhereCurrentSegmentChanged = {} as Vec2d\n\n\tpagePointWhereNextSegmentChanged = null as Vec2d | null\n\n\tlastRecordedPoint = {} as Vec2d\n\tmergeNextPoint = false\n\tcurrentLineLength = 0\n\n\tcanDraw = false\n\n\tmarkId = null as null | string\n\n\toverride onEnter = (info: TLPointerEventInfo) => {\n\t\tthis.markId = null\n\t\tthis.info = info\n\t\tthis.canDraw = !this.editor.getIsMenuOpen()\n\t\tthis.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone()\n\t\tif (this.canDraw) {\n\t\t\tthis.startShape()\n\t\t}\n\t}\n\n\toverride onPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tconst {\n\t\t\teditor: { inputs },\n\t\t} = this\n\n\t\tif (this.isPen !== inputs.isPen) {\n\t\t\t// The user made a palm gesture before starting a pen gesture;\n\t\t\t// ideally we'd start the new shape here but we could also just bail\n\t\t\t// as the next interaction will work correctly\n\t\t\tif (this.markId) {\n\t\t\t\tthis.editor.bailToMark(this.markId)\n\t\t\t\tthis.startShape()\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// If we came in from a menu but have no started dragging...\n\t\t\tif (!this.canDraw && inputs.isDragging) {\n\t\t\t\tthis.startShape()\n\t\t\t\tthis.canDraw = true // bad name\n\t\t\t}\n\t\t}\n\n\t\tif (this.canDraw) {\n\t\t\t// Don't update the shape if we haven't moved far enough from the last time we recorded a point\n\t\t\tif (inputs.isPen) {\n\t\t\t\tif (\n\t\t\t\t\tVec2d.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >=\n\t\t\t\t\t1 / this.editor.getZoomLevel()\n\t\t\t\t) {\n\t\t\t\t\tthis.lastRecordedPoint = inputs.currentPagePoint.clone()\n\t\t\t\t\tthis.mergeNextPoint = false\n\t\t\t\t} else {\n\t\t\t\t\tthis.mergeNextPoint = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mergeNextPoint = false\n\t\t\t}\n\n\t\t\tthis.updateShapes()\n\t\t}\n\t}\n\n\toverride onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tif (info.key === 'Shift') {\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'free': {\n\t\t\t\t\t// We've just entered straight mode, go to straight mode\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_free': {\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyUp: TLEventHandlers['onKeyUp'] = (info) => {\n\t\tif (info.key === 'Shift') {\n\t\t\tthis.editor.snaps.clear()\n\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'straight': {\n\t\t\t\t\t// We've just exited straight mode, go back to free mode\n\t\t\t\t\tthis.segmentMode = 'starting_free'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_straight': {\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\t\tthis.segmentMode = 'free'\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes()\n\t}\n\n\toverride onExit? = () => {\n\t\tthis.editor.snaps.clear()\n\t\tthis.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t}\n\n\tcanClose() {\n\t\treturn this.shapeType !== 'highlight'\n\t}\n\n\tgetIsClosed(segments: TLDrawShapeSegment[], size: TLDefaultSizeStyle) {\n\t\tif (!this.canClose()) return false\n\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\t\tconst firstPoint = segments[0].points[0]\n\t\tconst lastSegment = segments[segments.length - 1]\n\t\tconst lastPoint = lastSegment.points[lastSegment.points.length - 1]\n\n\t\treturn (\n\t\t\tfirstPoint !== lastPoint &&\n\t\t\tthis.currentLineLength > strokeWidth * 4 &&\n\t\t\tVec2d.Dist(firstPoint, lastPoint) < strokeWidth * 2\n\t\t)\n\t}\n\n\tprivate startShape() {\n\t\tconst {\n\t\t\tinputs: { originPagePoint, isPen },\n\t\t} = this.editor\n\n\t\tthis.markId = 'draw start ' + uniqueId()\n\t\tthis.editor.mark(this.markId)\n\n\t\tthis.isPen = isPen\n\n\t\tconst pressure = this.isPen ? this.info.point.z! * 1.25 : 0.5\n\n\t\tthis.segmentMode = this.editor.inputs.shiftKey ? 'straight' : 'free'\n\n\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\n\t\tthis.lastRecordedPoint = originPagePoint.clone()\n\n\t\tif (this.initialShape) {\n\t\t\tconst shape = this.editor.getShape<DrawableShape>(this.initialShape.id)\n\n\t\t\tif (shape && this.segmentMode === 'straight') {\n\t\t\t\t// Connect dots\n\n\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = true\n\n\t\t\t\tconst prevSegment = last(shape.props.segments)\n\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\t\t\t\tconst prevPoint = last(prevSegment.points)\n\t\t\t\tif (!prevPoint) throw Error('Expected a previous point!')\n\n\t\t\t\tconst { x, y } = this.editor.getPointInShapeSpace(shape, originPagePoint).toFixed()\n\n\t\t\t\tconst pressure = this.isPen ? this.info.point.z! * 1.25 : 0.5\n\n\t\t\t\tconst newSegment: TLDrawShapeSegment = {\n\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\tpoints: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: prevPoint.x,\n\t\t\t\t\t\t\ty: prevPoint.y,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\n\t\t\t\t// Convert prevPoint to page space\n\t\t\t\tconst prevPointPageSpace = Matrix2d.applyToPoint(\n\t\t\t\t\tthis.editor.getShapePageTransform(shape.id)!,\n\t\t\t\t\tprevPoint\n\t\t\t\t)\n\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = prevPointPageSpace\n\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\tconst segments = [...shape.props.segments, newSegment]\n\n\t\t\t\tthis.currentLineLength = this.getLineLength(segments)\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tshape.props.size\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial])\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Create a new shape\n\n\t\tthis.pagePointWhereCurrentSegmentChanged = originPagePoint.clone()\n\t\tconst id = createShapeId()\n\n\t\tthis.editor.createShapes<DrawableShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: this.shapeType,\n\t\t\t\tx: originPagePoint.x,\n\t\t\t\ty: originPagePoint.y,\n\t\t\t\tprops: {\n\t\t\t\t\tisPen: this.isPen,\n\t\t\t\t\tsegments: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t])\n\t\tthis.currentLineLength = 0\n\t\tthis.initialShape = this.editor.getShape<DrawableShape>(id)\n\t}\n\n\tprivate updateShapes() {\n\t\tconst { inputs } = this.editor\n\t\tconst { initialShape } = this\n\n\t\tif (!initialShape) return\n\n\t\tconst {\n\t\t\tid,\n\t\t\tprops: { size },\n\t\t} = initialShape\n\n\t\tconst shape = this.editor.getShape<DrawableShape>(id)!\n\n\t\tif (!shape) return\n\n\t\tconst { segments } = shape.props\n\n\t\tconst { x, y, z } = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed()\n\n\t\tconst newPoint = { x, y, z: this.isPen ? +(z! * 1.25).toFixed(2) : 0.5 }\n\n\t\tswitch (this.segmentMode) {\n\t\t\tcase 'starting_straight': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'straight'\n\n\t\t\t\t\tconst prevSegment = last(segments)\n\t\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\n\t\t\t\t\tconst prevLastPoint = last(prevSegment.points)\n\t\t\t\t\tif (!prevLastPoint) throw Error('Expected a previous last point!')\n\n\t\t\t\t\tlet newSegment: TLDrawShapeSegment\n\n\t\t\t\t\tconst newLastPoint = this.editor\n\t\t\t\t\t\t.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\t\t.toFixed()\n\t\t\t\t\t\t.toJson()\n\n\t\t\t\t\tif (prevSegment.type === 'straight') {\n\t\t\t\t\t\tthis.currentLineLength += Vec2d.Dist(prevLastPoint, newLastPoint)\n\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [{ ...prevLastPoint }, newLastPoint],\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst transform = this.editor.getShapePageTransform(shape)!\n\n\t\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = Matrix2d.applyToPoint(\n\t\t\t\t\t\t\ttransform,\n\t\t\t\t\t\t\tprevLastPoint\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [newLastPoint, newPoint],\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: [...segments, newSegment],\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tsegments,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial], {\n\t\t\t\t\t\tsquashing: true,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'starting_free': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'free'\n\n\t\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\t\tconst prevStraightSegment = newSegments[newSegments.length - 1]\n\t\t\t\t\tconst prevPoint = last(prevStraightSegment.points)\n\n\t\t\t\t\tif (!prevPoint) {\n\t\t\t\t\t\tthrow Error('No previous point!')\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the new free segment and interpolate the points between where the last line\n\t\t\t\t\t// ended and where the pointer is now\n\t\t\t\t\tconst newFreeSegment: TLDrawShapeSegment = {\n\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t...Vec2d.PointsBetween(prevPoint, newPoint, 6).map((p) => p.toFixed().toJson()),\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\n\t\t\t\t\tconst finalSegments = [...newSegments, newFreeSegment]\n\t\t\t\t\tthis.currentLineLength = this.getLineLength(finalSegments)\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: finalSegments,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tfinalSegments,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes([shapePartial], { squashing: true })\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'straight': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\n\t\t\t\tconst { pagePointWhereCurrentSegmentChanged } = this\n\t\t\t\tconst { currentPagePoint, ctrlKey } = this.editor.inputs\n\n\t\t\t\tif (!pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\n\t\t\t\tlet pagePoint: Vec2dModel\n\t\t\t\tlet shouldSnapToAngle = false\n\n\t\t\t\tif (this.didJustShiftClickToExtendPreviousShapeLine) {\n\t\t\t\t\tif (this.editor.inputs.isDragging) {\n\t\t\t\t\t\t// If we've just shift clicked to extend a line, only snap once we've started dragging\n\t\t\t\t\t\tshouldSnapToAngle = !ctrlKey\n\t\t\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If we're not shift clicking to extend a line, but we're holding shift, then we should snap\n\t\t\t\t\tshouldSnapToAngle = !ctrlKey // don't snap angle while snapping line\n\t\t\t\t}\n\n\t\t\t\tlet newPoint = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson()\n\t\t\t\tlet didSnap = false\n\t\t\t\tlet snapSegment: TLDrawShapeSegment | undefined = undefined\n\n\t\t\t\tconst shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey : ctrlKey\n\n\t\t\t\tif (shouldSnap) {\n\t\t\t\t\tif (newSegments.length > 2) {\n\t\t\t\t\t\tlet nearestPoint: Vec2dModel | undefined = undefined\n\t\t\t\t\t\tlet minDistance = 8 / this.editor.getZoomLevel()\n\n\t\t\t\t\t\t// Don't try to snap to the last two segments\n\t\t\t\t\t\tfor (let i = 0, n = segments.length - 2; i < n; i++) {\n\t\t\t\t\t\t\tconst segment = segments[i]\n\t\t\t\t\t\t\tif (!segment) break\n\t\t\t\t\t\t\tif (segment.type === 'free') continue\n\n\t\t\t\t\t\t\tconst first = segment.points[0]\n\t\t\t\t\t\t\tconst lastPoint = last(segment.points)\n\t\t\t\t\t\t\tif (!(first && lastPoint)) continue\n\n\t\t\t\t\t\t\t// Snap to the nearest point on the segment, if it's closer than the previous snapped point\n\t\t\t\t\t\t\tconst nearestPointOnSegment = Vec2d.NearestPointOnLineSegment(\n\t\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t\t\tlastPoint,\n\t\t\t\t\t\t\t\tnewPoint\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tconst distance = Vec2d.Dist(nearestPointOnSegment, newPoint)\n\n\t\t\t\t\t\t\tif (distance < minDistance) {\n\t\t\t\t\t\t\t\tnearestPoint = nearestPointOnSegment.toFixed().toJson()\n\t\t\t\t\t\t\t\tminDistance = distance\n\t\t\t\t\t\t\t\tsnapSegment = segment\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nearestPoint) {\n\t\t\t\t\t\t\tdidSnap = true\n\t\t\t\t\t\t\tnewPoint = nearestPoint\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (didSnap && snapSegment) {\n\t\t\t\t\tconst transform = this.editor.getShapePageTransform(shape)!\n\t\t\t\t\tconst first = snapSegment.points[0]\n\t\t\t\t\tconst lastPoint = last(snapSegment.points)\n\t\t\t\t\tif (!lastPoint) throw Error('Expected a last point!')\n\n\t\t\t\t\tconst A = Matrix2d.applyToPoint(transform, first)\n\n\t\t\t\t\tconst B = Matrix2d.applyToPoint(transform, lastPoint)\n\n\t\t\t\t\tconst snappedPoint = Matrix2d.applyToPoint(transform, newPoint)\n\n\t\t\t\t\tthis.editor.snaps.setLines([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\t\tpoints: [A, snappedPoint, B],\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t} else {\n\t\t\t\t\tthis.editor.snaps.clear()\n\n\t\t\t\t\tif (shouldSnapToAngle) {\n\t\t\t\t\t\t// Snap line angle to nearest 15 degrees\n\t\t\t\t\t\tconst currentAngle = Vec2d.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint)\n\t\t\t\t\t\tconst snappedAngle = snapAngle(currentAngle, 24)\n\t\t\t\t\t\tconst angleDiff = snappedAngle - currentAngle\n\n\t\t\t\t\t\tpagePoint = Vec2d.RotWith(\n\t\t\t\t\t\t\tcurrentPagePoint,\n\t\t\t\t\t\t\tpagePointWhereCurrentSegmentChanged,\n\t\t\t\t\t\t\tangleDiff\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpagePoint = currentPagePoint\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoint = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson()\n\t\t\t\t}\n\n\t\t\t\t// If the previous segment is a one point free shape and is the first segment of the line,\n\t\t\t\t// then the user just did a click-and-immediately-press-shift to create a new straight line\n\t\t\t\t// without continuing the previous line. In this case, we want to remove the previous segment.\n\n\t\t\t\tthis.currentLineLength += Vec2d.Dist(newSegment.points[0], newPoint)\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\ttype: 'straight',\n\t\t\t\t\tpoints: [newSegment.points[0], newPoint],\n\t\t\t\t}\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tsize\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial], { squashing: true })\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'free': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\t\t\t\tconst newPoints = [...newSegment.points]\n\n\t\t\t\tif (newPoints.length && this.mergeNextPoint) {\n\t\t\t\t\tconst { z } = newPoints[newPoints.length - 1]\n\t\t\t\t\tnewPoints[newPoints.length - 1] = {\n\t\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\t\tz: z ? Math.max(z, newPoint.z) : newPoint.z,\n\t\t\t\t\t}\n\t\t\t\t\t// Note: we could recompute the line length here, but it's not really necessary\n\t\t\t\t\t// this.currentLineLength = this.getLineLength(newSegments)\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentLineLength += Vec2d.Dist(newPoints[newPoints.length - 1], newPoint)\n\t\t\t\t\tnewPoints.push(newPoint)\n\t\t\t\t}\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\tpoints: newPoints,\n\t\t\t\t}\n\n\t\t\t\tthis.currentLineLength = this.getLineLength(newSegments)\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tnewSegments,\n\t\t\t\t\t\tsize\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial], { squashing: true })\n\n\t\t\t\t// Set a maximum length for the lines array; after 200 points, complete the line.\n\t\t\t\tif (newPoints.length > 500) {\n\t\t\t\t\tthis.editor.updateShapes([{ id, type: this.shapeType, props: { isComplete: true } }])\n\n\t\t\t\t\tconst { currentPagePoint } = this.editor.inputs\n\n\t\t\t\t\tconst newShapeId = createShapeId()\n\n\t\t\t\t\tthis.editor.createShapes<DrawableShape>([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: newShapeId,\n\t\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\t\tx: toFixed(currentPagePoint.x),\n\t\t\t\t\t\t\ty: toFixed(currentPagePoint.y),\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tisPen: this.isPen,\n\t\t\t\t\t\t\t\tsegments: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\t\t\t\t\tpoints: [{ x: 0, y: 0, z: this.isPen ? +(z! * 1.25).toFixed() : 0.5 }],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\n\t\t\t\t\tthis.initialShape = structuredClone(this.editor.getShape<DrawableShape>(newShapeId)!)\n\t\t\t\t\tthis.mergeNextPoint = false\n\t\t\t\t\tthis.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tthis.currentLineLength = 0\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLineLength(segments: TLDrawShapeSegment[]) {\n\t\tlet length = 0\n\n\t\tfor (const segment of segments) {\n\t\t\tfor (let i = 0; i < segment.points.length - 1; i++) {\n\t\t\t\tconst A = segment.points[i]\n\t\t\t\tconst B = segment.points[i + 1]\n\t\t\t\tlength += Vec2d.Sub(B, A).len2()\n\t\t\t}\n\t\t}\n\n\t\treturn Math.sqrt(length)\n\t}\n\n\toverride onPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel: TLEventHandlers['onCancel'] = () => {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt: TLEventHandlers['onInterrupt'] = () => {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this.markId) {\n\t\t\tthis.editor.bailToMark(this.markId)\n\t\t}\n\t\tthis.cancel()\n\t}\n\n\tcomplete() {\n\t\t// If we weren't focused when the drawing shape started, and if\n\t\t// we haven't dragged far enough to start dragging, then don't do\n\t\t// anything here. Most likely we clicked back into the canvas from\n\t\t// a menu or other UI element.\n\t\tif (!this.canDraw) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst { initialShape } = this\n\t\tif (!initialShape) return\n\t\tthis.editor.updateShapes([\n\t\t\t{ id: initialShape.id, type: initialShape.type, props: { isComplete: true } },\n\t\t])\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcancel() {\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],
  "mappings": "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",
  "names": ["pressure", "newPoint", "z"]
}
